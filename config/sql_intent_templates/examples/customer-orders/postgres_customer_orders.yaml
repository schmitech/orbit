templates:
  - id: find_order_by_id
    version: "1.0.0"
    description: "Find a specific order by its order ID/number"
    nl_examples:
      - "Show me order 12345"
      - "Find order number 67890"
      - "Get details for order #98765"
      - "Order 54321 details"
      - "What's in order 11111?"
      - "Look up order ID 22222"
      - "Show order #33333"
      - "Find order with ID 44444"
      - "Order number 55555 information"
      - "Get order 66666"
      - "Pull up order 77777"
      - "Display order #88888"
      - "I need order 99999"
      - "Show me the order 10001"
      - "What is order number 20002?"
    parameters:
      - name: order_id
        type: integer
        description: "Order ID/number to search for"
        required: true
        aliases: ["id", "order_number", "order_num", "number"]
    sql_template: |
      SELECT o.*, c.name as customer_name, c.email as customer_email,
             c.phone as customer_phone, c.city as customer_city,
             c.country as customer_country
      FROM orders o
      JOIN customers c ON o.customer_id = c.id
      WHERE o.id = %(order_id)s
    result_format: "summary"
    tags: ["order", "id", "number", "specific", "lookup", "find", "details"]
    semantic_tags:
      action: "lookup"
      primary_entity: "order"
      qualifiers: ["by_id", "specific"]
    approved: true

  - id: find_multiple_orders_by_ids
    version: "1.0.0"
    description: "Find multiple orders by their IDs/numbers"
    nl_examples:
      - "Show me orders 12345, 67890, and 54321"
      - "Find orders 11111 and 22222"
      - "Get orders #98765, #87654, #76543"
      - "Orders 10001, 10002, 10003"
      - "Look up order numbers 20001 through 20005"
      - "Show orders between 30000 and 30010"
      - "Find order IDs 40001 to 40003"
      - "Orders from 50000 to 50005"
      - "Get orders in range 60000-60010"
      - "Pull orders 70001, 70002, 70003, 70004"
    parameters:
      - name: order_ids
        type: string
        description: "Comma-separated list of order IDs or range (e.g., '12345,67890' or '10000-10005')"
        required: true
        aliases: ["ids", "order_numbers", "numbers"]
    sql_template: |
      SELECT o.*, c.name as customer_name, c.email as customer_email,
             c.city as customer_city, c.country as customer_country
      FROM orders o
      JOIN customers c ON o.customer_id = c.id
      WHERE o.id = ANY(string_to_array(%(order_ids)s::text, ',')::integer[])
      ORDER BY o.id
      LIMIT 100
    result_format: "table"
    tags: ["order", "multiple", "ids", "numbers", "list", "range", "batch"]
    semantic_tags:
      action: "lookup_list"
      primary_entity: "order"
      qualifiers: ["by_ids", "multiple"]
    approved: true

  - id: find_recent_order_by_order_id_pattern
    version: "1.0.0"
    description: "Find orders matching a specific ID pattern or range (optionally filtered by time period)"
    nl_examples:
      - "Show me all orders starting with 100"
      - "Find orders in the 2000s"
      - "Get orders between 5000 and 6000"
      - "Orders from 10000 onwards"
      - "Show recent orders above 20000"
      - "Find orders with IDs greater than 30000"
      - "Orders numbered 40000 and up"
      - "Get all orders after 50000"
      - "Show orders with ID over 60000"
      - "Recent orders starting from 70000"
    parameters:
      - name: min_order_id
        type: integer
        description: "Minimum order ID to search from"
        required: false
        aliases: ["from_id", "starting_id", "min_id"]
      - name: max_order_id
        type: integer
        description: "Maximum order ID to search up to"
        required: false
        aliases: ["to_id", "ending_id", "max_id"]
      - name: days_back
        type: integer
        description: "Number of days to look back (optional - if not provided, searches all orders)"
        required: false
        default: null
    sql_template: |
      SELECT o.*, c.name as customer_name, c.email as customer_email,
             c.city as customer_city, c.country as customer_country
      FROM orders o
      JOIN customers c ON o.customer_id = c.id
      WHERE 1=1
        {% if min_order_id %}AND o.id >= %(min_order_id)s{% endif %}
        {% if max_order_id %}AND o.id <= %(max_order_id)s{% endif %}
        {% if days_back %}AND o.order_date >= CURRENT_DATE - INTERVAL '%(days_back)s days'{% endif %}
      ORDER BY o.id DESC
      LIMIT 100
    result_format: "table"
    tags: ["order", "range", "pattern", "id", "starting", "above", "greater"]
    semantic_tags:
      action: "find_list"
      primary_entity: "order"
      qualifiers: ["by_id_range"]
    approved: true

  - id: find_order_by_customer_name
    version: "1.0.0"
    description: "Find orders for a customer by their name"
    nl_examples:
      - "Show me orders from customer John Smith"
      - "What did Jane Doe order?"
      - "Find all orders from customer Bob Johnson"
      - "Orders placed by Alice Wilson"
      - "Show me all orders from customer Mary Brown"
      - "Get orders for customer name David Lee"
      - "Customer Michael Davis orders"
      - "Find customer Sarah Johnson's purchases"
      - "Show me what customer Robert Williams bought"
    parameters:
      - name: customer_name
        type: string
        description: "Customer name to search for"
        required: true
        aliases: ["name", "client_name", "buyer_name"]
      - name: days_back
        type: integer
        description: "Number of days to look back"
        required: false
        default: 365
    sql_template: |
      SELECT o.*, c.name as customer_name, c.email as customer_email
      FROM orders o
      JOIN customers c ON o.customer_id = c.id
      WHERE LOWER(c.name) LIKE LOWER(%(customer_name)s)
        AND o.order_date >= CURRENT_DATE - INTERVAL '%(days_back)s days'
      ORDER BY o.order_date DESC
      LIMIT 100
    result_format: "table"
    tags: ["order", "customer", "name", "search", "person"]
    semantic_tags:
      action: "find_list"
      primary_entity: "order"
      secondary_entity: "customer"
      qualifiers: ["by_name", "by_person_name", "customer_name"]
    approved: true

  - id: find_order_by_customer_name_recent
    version: "1.0.0"
    description: "Find recent orders for a customer by their name within a specific time period"
    nl_examples:
      - "Show me orders from John Smith in the last 3 days"
      - "What did Jane Doe order this week?"
      - "Find all orders from Bob Johnson within the last 7 days"
      - "Recent orders from Alice Wilson"
      - "I'm looking for all orders from Shelia Olson within the last 3 days"
    parameters:
      - name: customer_name
        type: string
        description: "Customer name to search for"
        required: true
        aliases: ["name", "client_name", "buyer_name"]
      - name: days_back
        type: integer
        description: "Number of days to look back"
        required: true
    sql_template: |
      SELECT o.*, c.name as customer_name, c.email as customer_email, c.city as customer_city
      FROM orders o
      JOIN customers c ON o.customer_id = c.id
      WHERE LOWER(c.name) LIKE LOWER(%(customer_name)s)
        AND o.order_date >= CURRENT_DATE - INTERVAL '%(days_back)s days'
      ORDER BY o.order_date DESC
      LIMIT 100
    result_format: "table"
    tags: ["order", "customer", "name", "search", "recent", "time"]
    semantic_tags:
      action: "find_list"
      primary_entity: "order"
      secondary_entity: "customer"
      qualifiers: ["by_name", "recent"]
    approved: true

  - id: list_customers_by_time_period
    version: "1.0.0"
    description: "List all customers who placed orders within a specific time period"
    nl_examples:
      - "Who ordered from us last week?"
      - "Which customers placed orders this month?"
      - "Show me all customers who ordered in the last 7 days"
      - "Who are the customers that ordered recently?"
      - "List customers who made purchases last week"
      - "Which customers bought from us this week?"
      - "Show me recent customers"
      - "Who ordered in the past few days?"
      - "Who has been ordering from us?"
      - "List of customers who ordered"
      - "Show customers who placed orders"
      - "Who are our recent customers?"
      - "Who are the customers who ordered?"
      - "Who placed orders with us?"
      - "Who bought from us recently?"
      - "Who are the people who ordered?"
    parameters:
      - name: days_back
        type: integer
        description: "Number of days to look back"
        required: true
        default: 7
        aliases: ["time_period", "days", "period"]
    sql_template: |
      SELECT DISTINCT c.id as customer_id, c.name as customer_name, c.email as customer_email, 
             c.city as customer_city, c.country as customer_country,
             COUNT(o.id) as order_count,
             SUM(o.total) as total_spent,
             MAX(o.order_date) as last_order_date,
             MIN(o.order_date) as first_order_date
      FROM customers c
      JOIN orders o ON c.id = o.customer_id
      WHERE o.order_date >= CURRENT_DATE - INTERVAL '%(days_back)s days'
      GROUP BY c.id, c.name, c.email, c.city, c.country
      ORDER BY last_order_date DESC, total_spent DESC
      LIMIT 100
    result_format: "table"
    tags: ["customer", "list", "time", "period", "recent", "who", "ordered"]
    semantic_tags:
      action: "list_who"
      primary_entity: "customer"
      secondary_entity: "order"
      qualifiers: ["by_time_period", "recent", "who_ordered"]
    approved: true

  - id: find_order_by_customer_id
    version: "1.0.0"
    description: "Find orders for a customer by their ID"
    nl_examples:
      - "What did customer 1 buy last week?"
      - "Show orders for customer ID 5"
      - "Find orders from customer #10"
      - "Customer 123 orders"
      - "Get purchases for customer number 7"
    parameters:
      - name: customer_id
        type: integer
        description: "Customer ID to search for"
        required: true
        aliases: ["id", "customer_number", "customer_num"]
      - name: days_back
        type: integer
        description: "Number of days to look back"
        required: false
        default: 365
    sql_template: |
      SELECT o.*, c.name as customer_name, c.email as customer_email
      FROM orders o
      JOIN customers c ON o.customer_id = c.id
      WHERE c.id = %(customer_id)s
        AND o.order_date >= CURRENT_DATE - INTERVAL '%(days_back)s days'
      ORDER BY o.order_date DESC
      LIMIT 100
    result_format: "table"
    tags: ["order", "customer", "id", "search"]
    semantic_tags:
      action: "find_list"
      primary_entity: "order"
      secondary_entity: "customer"
      qualifiers: ["by_id"]
    approved: true

  - id: find_high_value_orders_time_period
    version: "1.0.0"
    description: "Find orders above a specific amount within a time period"
    nl_examples:
      - "Show me all orders over $500 from last month"
      - "Find expensive orders above $1000"
      - "List high-value orders from the last 30 days"
      - "Orders worth more than $750 this week"
      - "Which orders exceeded $2000 last quarter?"
      - "Give me orders greater than $1200 from past 60 days"
    parameters:
      - name: min_amount
        type: decimal
        description: "Minimum order amount"
        required: true
        aliases: ["amount", "value", "threshold"]
      - name: days_back
        type: integer
        description: "Number of days to look back"
        required: false
        default: 30
    sql_template: |
      SELECT o.*, c.name as customer_name, c.email as customer_email
      FROM orders o
      JOIN customers c ON o.customer_id = c.id
      WHERE o.total > %(min_amount)s
        AND o.order_date >= CURRENT_DATE - INTERVAL '%(days_back)s days'
      ORDER BY o.total DESC, o.order_date DESC
      LIMIT 100
    result_format: "table"
    tags: ["order", "amount", "value", "high", "expensive", "time"]
    semantic_tags:
      action: "find_list"
      primary_entity: "order"
      qualifiers: ["by_amount", "by_time_period"]
    approved: true

  - id: find_high_value_orders
    version: "1.0.0"
    description: "Find all orders above a specific amount"
    nl_examples:
      - "Find expensive orders above $1000"
      - "Show orders worth more than $750"
      - "Which orders exceeded $2000?"
      - "Give me the premium orders over $1500"
      - "Large transactions above $800 please"
      - "Find all big ticket items over $600"
      - "Orders greater than $1200"
    parameters:
      - name: min_amount
        type: decimal
        description: "Minimum order amount"
        required: true
        aliases: ["amount", "value", "threshold"]
    sql_template: |
      SELECT o.*, c.name as customer_name, c.email as customer_email
      FROM orders o
      JOIN customers c ON o.customer_id = c.id
      WHERE o.total > %(min_amount)s
      ORDER BY o.total DESC, o.order_date DESC
      LIMIT 100
    result_format: "table"
    tags: ["order", "amount", "value", "high", "expensive", "premium", "large"]
    semantic_tags:
      action: "find_list"
      primary_entity: "order"
      qualifiers: ["by_amount"]
    approved: true

  - id: find_biggest_orders_recent
    version: "1.0.0"
    description: "Find the highest value orders from recent time period"
    nl_examples:
      - "What are the biggest orders recently?"
      - "Show me the largest orders this month"
      - "Top orders by value from last week"
      - "Highest value transactions lately"
      - "Recent big orders"
    parameters:
      - name: days_back
        type: integer
        description: "Number of days to look back"
        required: false
        default: 30
      - name: limit
        type: integer
        description: "Number of orders to return"
        required: false
        default: 20
    sql_template: |
      SELECT o.*, c.name as customer_name, c.email as customer_email
      FROM orders o
      JOIN customers c ON o.customer_id = c.id
      WHERE o.order_date >= CURRENT_DATE - INTERVAL '%(days_back)s days'
      ORDER BY o.total DESC
      LIMIT %(limit)s
    result_format: "table"
    tags: ["order", "biggest", "largest", "top", "high", "recent"]
    semantic_tags:
      action: "find_top"
      primary_entity: "order"
      qualifiers: ["by_amount", "recent"]
    approved: true

  - id: find_low_value_orders_time_period
    version: "1.0.0"
    description: "Find orders below a specific amount within a time period"
    nl_examples:
      - "Show me all orders under $500 from last month"
      - "Find cheap orders below $100"
      - "List low-value orders from the last 30 days"
      - "Orders worth less than $250 this week"
      - "Find all orders below $500 in the last 20 days"
      - "Small purchases under $50 from past week"
    parameters:
      - name: max_amount
        type: decimal
        description: "Maximum order amount"
        required: true
        aliases: ["amount", "value", "threshold", "limit"]
      - name: days_back
        type: integer
        description: "Number of days to look back"
        required: false
        default: 30
    sql_template: |
      SELECT o.*, c.name as customer_name, c.email as customer_email
      FROM orders o
      JOIN customers c ON o.customer_id = c.id
      WHERE o.total < %(max_amount)s
        AND o.order_date >= CURRENT_DATE - INTERVAL '%(days_back)s days'
      ORDER BY o.total ASC, o.order_date DESC
      LIMIT 100
    result_format: "table"
    tags: ["order", "amount", "value", "low", "cheap", "small", "under", "below", "time"]
    semantic_tags:
      action: "find_list"
      primary_entity: "order"
      qualifiers: ["by_amount", "by_time_period", "low_value"]
    approved: true

  - id: find_orders_below_amount
    version: "1.0.0"
    description: "Find all orders below/under a specific dollar amount"
    nl_examples:
      - "Show me the tiny transactions below $25"
      - "Find orders below $100"
      - "Show all orders under $50"
      - "Find cheap orders below $100"
      - "Show orders worth less than $250"
      - "Small purchases under $50"
      - "Budget orders less than $75"
      - "Orders smaller than $150"
      - "Low value orders under $200"
      - "Transactions below $500"
      - "Orders less than $25"
    parameters:
      - name: max_amount
        type: decimal
        description: "Maximum order amount"
        required: true
        aliases: ["amount", "value", "threshold", "limit"]
    sql_template: |
      SELECT o.*, c.name as customer_name, c.email as customer_email
      FROM orders o
      JOIN customers c ON o.customer_id = c.id
      WHERE o.total < %(max_amount)s
      ORDER BY o.total ASC, o.order_date DESC
      LIMIT 100
    result_format: "table"
    tags: ["order", "amount", "value", "low", "cheap", "small", "tiny", "budget", "under", "below", "less"]
    semantic_tags:
      action: "find_list"
      primary_entity: "order"
      qualifiers: ["by_amount", "low_value"]
    approved: true

  - id: find_smallest_orders_recent
    version: "1.0.0"
    description: "Find the lowest value orders from recent time period"
    nl_examples:
      - "What are the smallest orders recently?"
      - "Show me the cheapest orders this month"
      - "Bottom orders by value from last week"
      - "Lowest value transactions lately"
      - "Recent small orders"
      - "Tiny orders from the past few days"
    parameters:
      - name: days_back
        type: integer
        description: "Number of days to look back"
        required: false
        default: 30
      - name: limit
        type: integer
        description: "Number of orders to return"
        required: false
        default: 20
    sql_template: |
      SELECT o.*, c.name as customer_name, c.email as customer_email
      FROM orders o
      JOIN customers c ON o.customer_id = c.id
      WHERE o.order_date >= CURRENT_DATE - INTERVAL '%(days_back)s days'
      ORDER BY o.total ASC
      LIMIT %(limit)s
    result_format: "table"
    tags: ["order", "smallest", "cheapest", "bottom", "low", "recent", "tiny"]
    semantic_tags:
      action: "find_bottom"
      primary_entity: "order"
      qualifiers: ["by_amount", "recent", "smallest"]
    approved: true

  - id: find_orders_between_amounts
    version: "1.0.0"
    description: "Find orders between two specific amounts"
    nl_examples:
      - "Show orders between $100 and $500"
      - "Find orders from $50 to $200"
      - "Orders between $1000 and $5000"
      - "Show me orders in the range of $100 to $300"
      - "Find all orders between $250 and $750"
      - "Orders priced between $20 and $100"
    parameters:
      - name: min_amount
        type: decimal
        description: "Minimum order amount"
        required: true
        aliases: ["from", "starting", "minimum"]
      - name: max_amount
        type: decimal
        description: "Maximum order amount"
        required: true
        aliases: ["to", "ending", "maximum"]
    sql_template: |
      SELECT o.*, c.name as customer_name, c.email as customer_email
      FROM orders o
      JOIN customers c ON o.customer_id = c.id
      WHERE o.total >= %(min_amount)s
        AND o.total <= %(max_amount)s
      ORDER BY o.total ASC, o.order_date DESC
      LIMIT 100
    result_format: "table"
    tags: ["order", "amount", "between", "range", "from", "to"]
    semantic_tags:
      action: "find_list"
      primary_entity: "order"
      qualifiers: ["by_amount_range", "between"]
    approved: true

  - id: find_orders_by_status
    version: "1.0.0"
    description: "Find orders by their current status"
    nl_examples:
      - "Show me all pending orders"
      - "What orders are still processing?"
      - "Which orders are waiting to be processed?"
      - "Orders that have been delivered"
      - "Show me the cancelled transactions"
      - "What's in pending status?"
      - "Find all shipped packages"
      - "Orders currently being processed"
      - "Show completed deliveries"
      - "Which orders are cancelled?"
    parameters:
      - name: status
        type: enum
        description: "Order status to filter by"
        required: true
        allowed_values: ["pending", "processing", "shipped", "delivered", "cancelled"]
        aliases: ["order_status", "state"]
    sql_template: |
      SELECT o.*, c.name as customer_name, c.email as customer_email
      FROM orders o
      JOIN customers c ON o.customer_id = c.id
      WHERE o.status = %(status)s
      ORDER BY o.order_date DESC
      LIMIT 100
    result_format: "table"
    tags: ["order", "status", "pending", "processing", "shipped", "delivered", "cancelled", "state"]
    semantic_tags:
      action: "filter_by"
      primary_entity: "order"
      qualifiers: ["by_status"]
    approved: true

  - id: find_orders_by_status_time_period
    version: "1.0.0"
    description: "Find orders by status within a specific time period"
    nl_examples:
      - "Find delivered orders from last week"
      - "List cancelled orders from the last month"
      - "Show shipped orders from yesterday"
      - "Find processing orders from this week"
      - "Show me all delivered orders from last month"
      - "Pending orders from the last 3 days"
      - "Cancelled orders this week"
      - "Show processing orders from past 7 days"
    parameters:
      - name: status
        type: enum
        description: "Order status to filter by"
        required: true
        allowed_values: ["pending", "processing", "shipped", "delivered", "cancelled"]
        aliases: ["order_status", "state"]
      - name: days_back
        type: integer
        description: "Number of days to look back"
        required: false
        default: 7
    sql_template: |
      SELECT o.*, c.name as customer_name, c.email as customer_email
      FROM orders o
      JOIN customers c ON o.customer_id = c.id
      WHERE o.status = %(status)s
        AND o.order_date >= CURRENT_DATE - INTERVAL '%(days_back)s days'
      ORDER BY o.order_date DESC
      LIMIT 100
    result_format: "table"
    tags: ["order", "status", "time", "period", "pending", "processing", "shipped", "delivered", "cancelled"]
    semantic_tags:
      action: "filter_by"
      primary_entity: "order"
      qualifiers: ["by_status", "by_time_period"]
    approved: true

  - id: find_orders_by_exact_date
    version: "1.0.0"
    description: "Find orders placed on a specific exact date"
    nl_examples:
      - "Show me orders on July 20th 2025"
      - "Find orders from 25/07/2025"
      - "Orders placed on 2025-07-20"
      - "What orders were made on July 25, 2025?"
      - "Show orders from 07/20/2025"
      - "Find all orders on 20-07-2025"
      - "Orders on July 20"
      - "Show me what happened on 2025-07-25"
    parameters:
      - name: order_date
        type: date
        description: "Exact date to search for orders (YYYY-MM-DD format)"
        required: true
        aliases: ["date", "on_date", "specific_date"]
        example: "2025-07-20"
    sql_template: |
      WITH input_params AS (
        SELECT 
          CASE 
            WHEN %(order_date)s = 'TODAY' THEN CURRENT_DATE
            WHEN %(order_date)s ~ '^\d{4}-\d{2}-\d{2}$' THEN to_date(%(order_date)s, 'YYYY-MM-DD')
            WHEN %(order_date)s ~ '^\d{2}/\d{2}/\d{4}$' THEN to_date(%(order_date)s, 'MM/DD/YYYY')
            WHEN %(order_date)s ~ '^\d{2}-\d{2}-\d{4}$' AND 
                 CAST(SPLIT_PART(%(order_date)s, '-', 1) AS INTEGER) > 12 THEN to_date(%(order_date)s, 'DD-MM-YYYY')
            WHEN %(order_date)s ~ '^\d{2}-\d{2}-\d{4}$' THEN to_date(%(order_date)s, 'MM-DD-YYYY')
            WHEN %(order_date)s ~ '^[A-Za-z]+ \d{1,2}[a-z]{0,2}(,? \d{4})?$' THEN
              to_date(
                REGEXP_REPLACE(
                  REGEXP_REPLACE(%(order_date)s, '(st|nd|rd|th)', '', 'gi'),
                  ',',
                  '',
                  'g'
                ) ||
                CASE 
                  WHEN %(order_date)s ~ '\d{4}' THEN ''
                  ELSE ' ' || EXTRACT(YEAR FROM CURRENT_DATE)::text
                END,
                'Month DD YYYY'
              )
            ELSE NULL
          END as order_date
      )
      SELECT o.*, c.name as customer_name, c.email as customer_email
      FROM orders o
      JOIN customers c ON o.customer_id = c.id
      CROSS JOIN input_params ip
      WHERE ip.order_date IS NOT NULL
        AND DATE(o.order_date) = ip.order_date
      ORDER BY o.order_date DESC, o.total DESC
      LIMIT 100
    result_format: "table"
    tags: ["order", "date", "exact", "specific", "on", "July", "day"]
    semantic_tags:
      action: "find_list"
      primary_entity: "order"
      qualifiers: ["by_exact_date"]
    approved: true

  - id: find_orders_by_amount_and_date
    version: "1.0.0"
    description: "Find orders above/below a specific amount on an exact date"
    nl_examples:
      - "Show me orders above $500 on July 20th 2025"
      - "Find orders over $1000 from 25/07/2025"
      - "Orders above $100 placed on 2025-07-20"
      - "Show orders under $50 on July 25, 2025"
      - "Find expensive orders over $500 from 07/20/2025"
      - "Orders below $200 on 20-07-2025"
      - "High value orders above $1000 on July 20"
    parameters:
      - name: order_date
        type: date
        description: "Exact date to search for orders (YYYY-MM-DD format)"
        required: true
        aliases: ["date", "on_date", "specific_date"]
        example: "2025-07-20"
      - name: min_amount
        type: decimal
        description: "Minimum order amount (use for 'above/over' queries)"
        required: false
        default: null
        aliases: ["above", "over", "greater_than", "minimum"]
      - name: max_amount
        type: decimal
        description: "Maximum order amount (use for 'below/under' queries)"
        required: false
        default: null
        aliases: ["below", "under", "less_than", "maximum"]
    sql_template: |
      WITH input_params AS (
        SELECT 
          CASE 
            WHEN %(order_date)s = 'TODAY' THEN CURRENT_DATE
            WHEN %(order_date)s ~ '^\d{4}-\d{2}-\d{2}$' THEN to_date(%(order_date)s, 'YYYY-MM-DD')
            WHEN %(order_date)s ~ '^\d{2}/\d{2}/\d{4}$' THEN to_date(%(order_date)s, 'MM/DD/YYYY')
            WHEN %(order_date)s ~ '^\d{2}-\d{2}-\d{4}$' AND 
                 CAST(SPLIT_PART(%(order_date)s, '-', 1) AS INTEGER) > 12 THEN to_date(%(order_date)s, 'DD-MM-YYYY')
            WHEN %(order_date)s ~ '^\d{2}-\d{2}-\d{4}$' THEN to_date(%(order_date)s, 'MM-DD-YYYY')
            WHEN %(order_date)s ~ '^[A-Za-z]+ \d{1,2}[a-z]{0,2}(,? \d{4})?$' THEN
              to_date(
                REGEXP_REPLACE(
                  REGEXP_REPLACE(%(order_date)s, '(st|nd|rd|th)', '', 'gi'),
                  ',',
                  '',
                  'g'
                ) ||
                CASE 
                  WHEN %(order_date)s ~ '\d{4}' THEN ''
                  ELSE ' ' || EXTRACT(YEAR FROM CURRENT_DATE)::text
                END,
                'Month DD YYYY'
              )
            ELSE NULL
          END as order_date,
          CASE 
            WHEN %(min_amount)s IS NULL THEN NULL
            ELSE %(min_amount)s::numeric
          END as min_amount,
          CASE 
            WHEN %(max_amount)s IS NULL THEN NULL
            ELSE %(max_amount)s::numeric
          END as max_amount
      )
      SELECT o.*, c.name as customer_name, c.email as customer_email
      FROM orders o
      JOIN customers c ON o.customer_id = c.id
      CROSS JOIN input_params ip
      WHERE ip.order_date IS NOT NULL
        AND DATE(o.order_date) = ip.order_date
        AND (ip.min_amount IS NULL OR o.total >= ip.min_amount)
        AND (ip.max_amount IS NULL OR o.total <= ip.max_amount)
      ORDER BY o.order_date DESC, o.total DESC
      LIMIT 100
    result_format: "table"
    tags: ["order", "date", "exact", "amount", "above", "below", "over", "under", "July", "expensive", "cheap"]
    semantic_tags:
      action: "find_list"
      primary_entity: "order"
      qualifiers: ["by_exact_date", "by_amount"]
    approved: true

  - id: calculate_customer_lifetime_value_by_id
    version: "1.0.0"
    description: "Calculate lifetime value and statistics for a customer by their ID"
    nl_examples:
      - "What's the lifetime value of customer 123?"
      - "How much has customer 456 spent in total?"
      - "Show me the total revenue from customer 89"
      - "Calculate customer 12's lifetime spending"
      - "What's customer 567's total purchase amount?"
      - "How valuable is customer 234 to us?"
      - "Total sales to customer 890"
      - "Customer 345 lifetime statistics"
      - "Give me a summary for customer 123"
      - "What's the total spent by customer 4124?"
      - "How much has customer 1001 spent?"
      - "Customer 9999 total spending"
      - "Show analytics for customer 2050"
      - "Customer ID 789 lifetime value"
      - "Total revenue from customer number 555"
    parameters:
      - name: customer_id
        type: integer
        description: "Customer ID to analyze"
        required: true
        aliases: ["id", "customer_number", "customer_num"]
    sql_template: |
      SELECT 
        c.id as customer_id,
        c.name as customer_name,
        c.email as customer_email,
        c.city as customer_city,
        c.country as customer_country,
        c.created_at as customer_since,
        COUNT(o.id) as total_orders,
        COALESCE(SUM(o.total), 0) as lifetime_value,
        COALESCE(AVG(o.total), 0) as average_order_value,
        COALESCE(MIN(o.total), 0) as smallest_order,
        COALESCE(MAX(o.total), 0) as largest_order,
        MIN(o.order_date) as first_order_date,
        MAX(o.order_date) as last_order_date,
        COUNT(CASE WHEN o.status = 'pending' THEN 1 END) as pending_orders,
        COUNT(CASE WHEN o.status = 'processing' THEN 1 END) as processing_orders,
        COUNT(CASE WHEN o.status = 'shipped' THEN 1 END) as shipped_orders,
        COUNT(CASE WHEN o.status = 'delivered' THEN 1 END) as delivered_orders,
        COUNT(CASE WHEN o.status = 'cancelled' THEN 1 END) as cancelled_orders
      FROM customers c
      LEFT JOIN orders o ON c.id = o.customer_id
      WHERE c.id = %(customer_id)s
      GROUP BY c.id, c.name, c.email, c.city, c.country, c.created_at
    result_format: "summary"
    tags: ["customer", "analytics", "lifetime", "value", "total", "spending", "revenue", "statistics", "summary", "id", "number", "4124", "1001", "9999", "numeric"]
    semantic_tags:
      action: "calculate_summary"
      primary_entity: "customer"
      qualifiers: ["lifetime_value", "by_id"]
    approved: true

  - id: calculate_customer_lifetime_value_by_name
    version: "1.0.0"
    description: "Calculate lifetime value and statistics for a customer by their name"
    nl_examples:
      - "What's the total spent by customer John Doe?"
      - "How much has Maria Smith spent in total?"
      - "Show me the lifetime value of Sarah Connor"
      - "Calculate John Smith's total spending"
      - "What's Jane Wilson's purchase history summary?"
      - "How valuable is Robert Johnson to us?"
      - "Total revenue from Michael Brown"
      - "Jessica Davis lifetime statistics"
    parameters:
      - name: customer_name
        type: string
        description: "Customer name to search for"
        required: true
        aliases: ["name", "client_name", "buyer_name"]
    sql_template: |
      SELECT 
        c.id as customer_id,
        c.name as customer_name,
        c.email as customer_email,
        c.city as customer_city,
        c.country as customer_country,
        c.created_at as customer_since,
        COUNT(o.id) as total_orders,
        COALESCE(SUM(o.total), 0) as lifetime_value,
        COALESCE(AVG(o.total), 0) as average_order_value,
        COALESCE(MIN(o.total), 0) as smallest_order,
        COALESCE(MAX(o.total), 0) as largest_order,
        MIN(o.order_date) as first_order_date,
        MAX(o.order_date) as last_order_date,
        COUNT(CASE WHEN o.status = 'pending' THEN 1 END) as pending_orders,
        COUNT(CASE WHEN o.status = 'processing' THEN 1 END) as processing_orders,
        COUNT(CASE WHEN o.status = 'shipped' THEN 1 END) as shipped_orders,
        COUNT(CASE WHEN o.status = 'delivered' THEN 1 END) as delivered_orders,
        COUNT(CASE WHEN o.status = 'cancelled' THEN 1 END) as cancelled_orders
      FROM customers c
      LEFT JOIN orders o ON c.id = o.customer_id
      WHERE LOWER(c.name) LIKE LOWER(%(customer_name)s)
      GROUP BY c.id, c.name, c.email, c.city, c.country, c.created_at
      ORDER BY lifetime_value DESC
      LIMIT 10
    result_format: "summary"
    tags: ["customer", "analytics", "lifetime", "value", "total", "spending", "revenue", "statistics", "name", "summary"]
    semantic_tags:
      action: "calculate_summary"
      primary_entity: "customer"
      qualifiers: ["lifetime_value", "by_name"]
    approved: true

  - id: customer_spending_analysis_by_numeric_id
    version: "1.0.0"
    description: "Analyze customer spending and value by numeric customer ID"
    nl_examples:
      - "What's the total spent by customer 4124?"
      - "How much has customer 1001 spent?"
      - "Customer 9999 total spending"
      - "Show spending for customer 2050"
      - "Customer 789 analytics"
      - "Total from customer number 555"
      - "Customer ID 3456 lifetime value"
      - "How much did customer 7890 spend?"
      - "Customer 1234 revenue analysis"
      - "Spending summary for customer 5678"
    parameters:
      - name: customer_id
        type: integer
        description: "Numeric customer ID to analyze"
        required: true
        aliases: ["id", "customer_number", "number", "numeric_id"]
    sql_template: |
      SELECT 
        c.id as customer_id,
        c.name as customer_name,
        c.email as customer_email,
        COUNT(o.id) as total_orders,
        COALESCE(SUM(o.total), 0) as total_spent,
        COALESCE(AVG(o.total), 0) as average_order_value,
        MAX(o.order_date) as last_order_date
      FROM customers c
      LEFT JOIN orders o ON c.id = o.customer_id
      WHERE c.id = %(customer_id)s
      GROUP BY c.id, c.name, c.email
    result_format: "summary"
    tags: ["customer", "spending", "total", "numeric", "id", "4124", "1001", "9999", "2050", "analytics", "number"]
    semantic_tags:
      action: "calculate_summary"
      primary_entity: "customer"
      qualifiers: ["spending_analysis", "numeric_id"]
    approved: true

  - id: find_orders_by_customer_city
    version: "1.0.0"
    description: "Find orders from customers in a specific city or location"
    nl_examples:
      - "Show orders from customers in New York"
      - "Find orders from customers located in Los Angeles"  
      - "What orders came from the city of Chicago?"
      - "Orders from customers in San Francisco"
      - "Show me orders from customers in the city of Boston"
      - "Which customers from the city of Seattle ordered?"
      - "Orders from customers in Dallas city"
      - "Find purchases from customers in Miami"
      - "Orders originating from customers in Denver"
      - "Show transactions from customers in Houston"
      - "Orders from customers located in Phoenix"
      - "Customer orders from the city of Atlanta"
      - "Purchases from customers in Las Vegas"
      - "Orders from customers located in Toronto"
      - "Show me customers from the city of Montreal"
    parameters:
      - name: city
        type: string
        description: "City name to filter customers by"
        required: true
        aliases: ["customer_city", "location", "from_city"]
    sql_template: |
      SELECT o.*, c.name as customer_name, c.email as customer_email, 
             c.city as customer_city, c.country as customer_country
      FROM orders o
      JOIN customers c ON o.customer_id = c.id
      WHERE LOWER(c.city) LIKE LOWER(%(city)s)
      ORDER BY o.order_date DESC
      LIMIT 100
    result_format: "table"
    tags: ["order", "customer", "city", "location", "geographic", "New York", "Los Angeles", "Chicago", "San Francisco", "Boston", "Seattle", "Dallas", "Miami", "Denver", "Houston"]
    semantic_tags:
      action: "find_list"
      primary_entity: "order"
      secondary_entity: "customer"
      qualifiers: ["by_customer_city", "geographic"]
    approved: true

  - id: find_customers_by_city_who_ordered
    version: "1.0.0"
    description: "Find customers from a specific city who have placed orders"
    nl_examples:
      - "Which customers from Seattle ordered?"
      - "Show me customers from New York who made purchases"
      - "List customers from Chicago with orders"
      - "Who are the customers from Miami that ordered?"
      - "Boston customers who have purchased"
      - "Denver customers with orders"
      - "Show active customers from Dallas"
    parameters:
      - name: city
        type: string
        description: "City name to filter customers by"
        required: true
        aliases: ["customer_city", "location", "from_city"]
    sql_template: |
      SELECT DISTINCT c.id as customer_id, c.name as customer_name, 
             c.email as customer_email, c.city as customer_city, 
             c.country as customer_country,
             COUNT(o.id) as total_orders,
             SUM(o.total) as total_spent,
             MAX(o.order_date) as last_order_date
      FROM customers c
      JOIN orders o ON c.id = o.customer_id
      WHERE LOWER(c.city) LIKE LOWER(%(city)s)
      GROUP BY c.id, c.name, c.email, c.city, c.country
      ORDER BY total_spent DESC, last_order_date DESC
      LIMIT 50
    result_format: "table"
    tags: ["customer", "city", "location", "geographic", "who", "ordered", "purchased", "Seattle", "New York", "Chicago", "Miami", "Boston", "Denver", "Dallas"]
    semantic_tags:
      action: "find_list"
      primary_entity: "customer"
      qualifiers: ["by_city", "who_ordered", "geographic"]
    approved: true

  - id: find_top_buyers_by_spending
    version: "1.0.0"
    description: "Find the top customers/buyers ranked by total spending amount"
    nl_examples:
      - "Show me the Top 5 buyers please"
      - "Who are our top 10 customers?"
      - "Find the biggest spenders"
      - "Show me the top customers by spending"
      - "Who are our best buyers?"
      - "Top 5 customers by revenue"
      - "Show the highest spending customers"
      - "Find our most valuable customers"
      - "Top buyers by total purchases"
      - "Show me the top 3 spenders"
      - "Who spent the most?"
      - "Best customers by lifetime value"
    parameters:
      - name: limit
        type: integer
        description: "Number of top customers to return"
        required: false
        default: 10
        aliases: ["top", "count", "number"]
    sql_template: |
      SELECT 
        c.id as customer_id,
        c.name as customer_name,
        c.email as customer_email,
        c.city as customer_city,
        c.country as customer_country,
        COUNT(o.id) as total_orders,
        SUM(o.total) as total_spent,
        AVG(o.total) as average_order_value,
        MAX(o.order_date) as last_order_date,
        MIN(o.order_date) as first_order_date
      FROM customers c
      JOIN orders o ON c.id = o.customer_id
      GROUP BY c.id, c.name, c.email, c.city, c.country
      ORDER BY total_spent DESC
      LIMIT %(limit)s
    result_format: "table"
    tags: ["customer", "top", "buyers", "best", "highest", "spending", "spenders", "valuable", "revenue", "biggest", "most"]
    semantic_tags:
      action: "rank_list"
      primary_entity: "customer"
      qualifiers: ["top_by_spending", "buyers"]
    approved: true

  - id: find_customer_by_email # FIXME
    version: "1.0.0"
    description: "Find customer information by their email address"
    nl_examples:
      - "Find customer with email john@example.com"
      - "Search for user@gmail.com"
      - "Who has the email address sarah@company.com?"
      - "Customer with email mike@domain.org"
      - "Look up buyer@email.net"
      - "Find customer mary@test.com"
      - "Search for admin@business.org"
      - "Who owns email contact@store.com?"
      - "Customer lookup for info@client.net"
      - "Find user with email address support@website.com"
      - "Look up sescudero202507220947037871@oscuro.org please"
      - "Search for customer with email test123@company.org"
      - "Find the customer info@example.com"
      - "Who is customer support@website.net?"
      - "Get customer details for person@domain.com"
      - "Show me the customer with email test@test.com"
      - "Find customer by email address user123@mail.org"
      - "Customer information for contact@business.net"
      - "What customer has email admin@company.com?"
      - "Lookup customer email test@example.org"
      - "Find customer with email tcoret20250921190822468@dunlap.net"
      - "Search customer by email long.email.address@company-name.org"
      - "Get customer with email address short@co.uk"
    parameters:
      - name: email
        type: string
        description: "Customer email address to search for"
        required: true
        aliases: ["email_address", "customer_email", "user_email"]
        pattern: "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$"
    sql_template: |
      SELECT 
        c.id as customer_id,
        c.name as customer_name,
        c.email as customer_email,
        c.phone as customer_phone,
        c.city as customer_city,
        c.country as customer_country,
        c.created_at as customer_since,
        COUNT(o.id) as total_orders,
        COALESCE(SUM(o.total), 0) as total_spent,
        MAX(o.order_date) as last_order_date
      FROM customers c
      LEFT JOIN orders o ON c.id = o.customer_id
      WHERE LOWER(c.email) = LOWER(%(email)s)
      GROUP BY c.id, c.name, c.email, c.phone, c.city, c.country, c.created_at
    result_format: "summary"
    tags: ["customer", "email", "search", "lookup", "find", "@", "gmail", "domain", "address", "oscuro", "org", "sescudero", "com", "net"]
    semantic_tags:
      action: "search_find"
      primary_entity: "customer"
      qualifiers: ["by_email"]
    approved: true

  - id: find_inactive_dormant_customers
    version: "1.0.0"
    description: "Find customers who haven't placed orders recently (inactive/dormant customers)"
    nl_examples:
      - "Show inactive customers"
      - "Who hasn't ordered in 90 days?"
      - "Find dormant customers"
      - "Customers not buying recently"
      - "Show me who stopped ordering"
      - "Who hasn't ordered in 6 months?"
      - "Find customers who stopped buying"
      - "Show dormant customers from last 3 months"
      - "Inactive customers who haven't purchased"
      - "Customers who haven't ordered lately"
      - "Show me customers who went quiet"
      - "Find customers who stopped purchasing"
    parameters:
      - name: days_inactive
        type: integer
        description: "Number of days of inactivity to consider dormant"
        required: false
        default: 90
        aliases: ["days", "inactive_days", "dormant_period", "days_back"]
    sql_template: |
      SELECT DISTINCT
        c.id as customer_id,
        c.name as customer_name,
        c.email as customer_email,
        c.city as customer_city,
        c.country as customer_country,
        c.created_at as customer_since,
        COUNT(o.id) as total_orders,
        COALESCE(SUM(o.total), 0) as total_spent,
        MAX(o.order_date) as last_order_date,
        CURRENT_DATE - MAX(o.order_date) as days_since_last_order
      FROM customers c
      LEFT JOIN orders o ON c.id = o.customer_id
      WHERE c.id NOT IN (
        SELECT DISTINCT customer_id
        FROM orders
        WHERE order_date >= CURRENT_DATE - INTERVAL '%(days_inactive)s days'
      )
      GROUP BY c.id, c.name, c.email, c.city, c.country, c.created_at
      ORDER BY last_order_date ASC NULLS LAST
      LIMIT 100
    result_format: "table"
    tags: ["customer", "inactive", "dormant", "stopped", "not", "buying", "ordering", "quiet", "90", "days", "months"]
    semantic_tags:
      action: "find_list"
      primary_entity: "customer"
      qualifiers: ["inactive", "dormant", "not_recent"]
    approved: true

  - id: find_orders_by_shipping_country
    version: "1.0.0"
    description: "Find orders by their shipping destination country"
    nl_examples:
      - "Show orders shipped to the United States"
      - "Orders delivered to European countries"
      - "Shipping to Asian countries"
      - "Canadian customers shipping abroad"
      - "Orders with international shipping addresses"
      - "Show me international shipments"
      - "Orders shipped outside Canada"
      - "International delivery orders"
      - "Cross-border orders"
      - "Orders shipped to France"
      - "Show deliveries to Germany"
      - "Orders going to Japan"
    parameters:
      - name: shipping_country
        type: string
        description: "Shipping destination country"
        required: true
        aliases: ["country", "destination", "shipped_to"]
    sql_template: |
      SELECT o.*, c.name as customer_name, c.email as customer_email,
             c.city as customer_city, c.country as customer_country
      FROM orders o
      JOIN customers c ON o.customer_id = c.id
      WHERE LOWER(c.country) LIKE LOWER(%(shipping_country)s)
      ORDER BY o.order_date DESC
      LIMIT 100
    result_format: "table"
    tags: ["order", "shipping", "country", "international", "delivered", "abroad", "cross-border", "United States", "European", "Asian", "Canadian", "France", "Germany", "Japan"]
    semantic_tags:
      action: "find_list"
      primary_entity: "order"
      qualifiers: ["by_shipping_country", "international"]
    approved: true

  - id: find_international_orders_by_amount
    version: "1.0.0"
    description: "Find international orders above a specific amount"
    nl_examples:
      - "International orders over $200"
      - "Show international orders above $500"
      - "Cross-border orders over $100"
      - "International shipments above $1000"
      - "High-value international orders over $300" # Works
      - "Expensive international deliveries above $250"
      - "International orders exceeding $400"
      - "Find international orders greater than $150"
      - "Orders from abroad over $200"
      - "Foreign orders above $500"
      - "International transactions over $100"
      - "Cross-border purchases above $300"
      - "International sales exceeding $250"
      - "Overseas orders over $400"
    parameters:
      - name: min_amount
        type: decimal
        description: "Minimum order amount for international orders"
        required: true
        aliases: ["amount", "over", "above", "minimum", "exceeding", "greater_than"]
      - name: exclude_country
        type: string
        description: "Country to exclude (typically home country)"
        required: false
        default: "Canada"
        aliases: ["home_country", "domestic"]
    sql_template: |
      SELECT o.*, c.name as customer_name, c.email as customer_email,
             c.city as customer_city, c.country as customer_country
      FROM orders o
      JOIN customers c ON o.customer_id = c.id
      WHERE o.total >= %(min_amount)s
        AND (c.country IS NOT NULL
             AND LOWER(c.country) != LOWER(%(exclude_country)s))
      ORDER BY o.total DESC, o.order_date DESC
      LIMIT 100
    result_format: "table"
    tags: ["order", "orders", "international", "cross-border", "foreign", "abroad", "overseas", "amount", "over", "above", "exceeding", "greater", "shipments", "deliveries", "transactions", "purchases", "sales", "expensive", "high-value", "$200", "$500", "$100", "$300", "$400", "$150", "$250", "$1000"]
    semantic_tags:
      action: "find_list"
      primary_entity: "order"
      qualifiers: ["international", "by_amount"]
    approved: true

  - id: find_international_vs_domestic_orders
    version: "1.0.0"
    description: "Find orders that are international (shipped outside home country)"
    nl_examples:
      - "Show me international shipments"
      - "Orders shipped outside Canada" # Works
      - "International delivery orders"
      - "Cross-border orders"
      - "Show international orders only"
      - "Orders delivered internationally"
      - "Non-domestic shipments"
    parameters:
      - name: home_country
        type: string
        description: "Home country to compare against"
        required: false
        default: "Canada"
        aliases: ["domestic_country", "base_country"]
    sql_template: |
      SELECT o.*, c.name as customer_name, c.email as customer_email,
             c.city as customer_city, c.country as customer_country,
             CASE 
               WHEN LOWER(c.country) != LOWER(%(home_country)s) THEN 'International' 
               ELSE 'Domestic' 
             END as shipment_type
      FROM orders o
      JOIN customers c ON o.customer_id = c.id
      WHERE c.country IS NOT NULL 
        AND LOWER(c.country) != LOWER(%(home_country)s)
      ORDER BY o.order_date DESC
      LIMIT 100
    result_format: "table"
    tags: ["order", "international", "cross-border", "outside", "abroad", "non-domestic", "shipments", "delivery"]
    semantic_tags:
      action: "find_list"
      primary_entity: "order"
      qualifiers: ["international_only"]
    approved: true

  - id: find_new_customers_by_time_period
    version: "1.0.0"
    description: "Find new customers who registered within a specific time period"
    nl_examples:
      - "Show me new customers from Aug 1 2025"
      - "Who are the new customers this week?"
      - "Find customers who registered in the last 7 days"
      - "Show new customers from last month"
      - "List recently registered customers"
      - "New customers who joined this month"
      - "Show me customers who signed up recently"
      - "Find new customers from the past 3 days"
      - "Who registered in the last 30 days?"
      - "Show new customer registrations"
      - "Recent customer signups"
      - "New customers who joined us"
    parameters:
      - name: days_back
        type: integer
        description: "Number of days to look back from today"
        required: false
        default: 7
        aliases: ["days", "period", "time_period"]
    sql_template: |
      SELECT 
        c.id as customer_id,
        c.name as customer_name,
        c.email as customer_email,
        c.phone as customer_phone,
        c.city as customer_city,
        c.country as customer_country,
        c.created_at as registration_date,
        CURRENT_DATE - DATE(c.created_at) as days_since_registration,
        COUNT(o.id) as total_orders,
        COALESCE(SUM(o.total), 0) as total_spent
      FROM customers c
      LEFT JOIN orders o ON c.id = o.customer_id
      WHERE c.created_at >= CURRENT_DATE - INTERVAL '%(days_back)s days'
      GROUP BY c.id, c.name, c.email, c.phone, c.city, c.country, c.created_at
      ORDER BY c.created_at DESC
      LIMIT 100
    result_format: "table"
    tags: ["customer", "new", "registered", "joined", "signed", "recent", "registration", "signup"]
    semantic_tags:
      action: "find_list"
      primary_entity: "customer"
      qualifiers: ["new", "by_registration_date", "recent"]
    approved: true

  - id: find_new_customers_from_specific_date
    version: "1.0.0"
    description: "Find new customers who registered from a specific date onwards"
    nl_examples:
      - "Show me new customers from Aug 1 2025"
      - "Find customers who registered since July 15, 2025"
      - "New customers from 2025-08-01"
      - "Who registered after August 1st?"
      - "Show customers who joined since 08/01/2025"
      - "New customers from August 1st, 2025"
      - "Find registrations since Aug 1"
      - "Customers who signed up from August 1"
    parameters:
      - name: from_date
        type: date
        description: "Start date to find new customers from (YYYY-MM-DD format)"
        required: true
        aliases: ["start_date", "since_date", "from", "since"]
        example: "2025-08-01"
    sql_template: |
      WITH input_params AS (
        SELECT 
          CASE 
            WHEN %(from_date)s = 'TODAY' THEN CURRENT_DATE
            WHEN %(from_date)s ~ '^\d{4}-\d{2}-\d{2}$' THEN to_date(%(from_date)s, 'YYYY-MM-DD')
            WHEN %(from_date)s ~ '^\d{2}/\d{2}/\d{4}$' THEN to_date(%(from_date)s, 'MM/DD/YYYY')
            WHEN %(from_date)s ~ '^\d{2}-\d{2}-\d{4}$' AND 
                 CAST(SPLIT_PART(%(from_date)s, '-', 1) AS INTEGER) > 12 THEN to_date(%(from_date)s, 'DD-MM-YYYY')
            WHEN %(from_date)s ~ '^\d{2}-\d{2}-\d{4}$' THEN to_date(%(from_date)s, 'MM-DD-YYYY')
            WHEN %(from_date)s ~ '^[A-Za-z]+ \d{1,2}[a-z]{0,2}(,? \d{4})?$' THEN
              to_date(
                REGEXP_REPLACE(
                  REGEXP_REPLACE(%(from_date)s, '(st|nd|rd|th)', '', 'gi'),
                  ',',
                  '',
                  'g'
                ) ||
                CASE 
                  WHEN %(from_date)s ~ '\d{4}' THEN ''
                  ELSE ' ' || EXTRACT(YEAR FROM CURRENT_DATE)::text
                END,
                'Month DD YYYY'
              )
            ELSE NULL
          END as from_date
      )
      SELECT 
        c.id as customer_id,
        c.name as customer_name,
        c.email as customer_email,
        c.phone as customer_phone,
        c.city as customer_city,
        c.country as customer_country,
        c.created_at as registration_date,
        CURRENT_DATE - DATE(c.created_at) as days_since_registration,
        COUNT(o.id) as total_orders,
        COALESCE(SUM(o.total), 0) as total_spent
      FROM customers c
      LEFT JOIN orders o ON c.id = o.customer_id
      CROSS JOIN input_params ip
      WHERE ip.from_date IS NOT NULL
        AND DATE(c.created_at) >= ip.from_date
      GROUP BY c.id, c.name, c.email, c.phone, c.city, c.country, c.created_at
      ORDER BY c.created_at DESC
      LIMIT 100
    result_format: "table"
    tags: ["customer", "new", "registered", "from", "since", "specific", "date", "Aug", "August", "July"]
    semantic_tags:
      action: "find_list"
      primary_entity: "customer"
      qualifiers: ["new", "from_specific_date"]
    approved: true
