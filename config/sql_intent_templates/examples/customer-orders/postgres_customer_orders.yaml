templates:
  - id: find_order_by_customer_name
    version: "1.0.0"
    description: "Find orders for a customer by their name"
    nl_examples:
      - "Show me orders from customer John Smith"
      - "What did Jane Doe order?"
      - "Find all orders from customer Bob Johnson"
      - "Orders placed by Alice Wilson"
      - "Show me all orders from customer Mary Brown"
      - "Get orders for customer name David Lee"
      - "Customer Michael Davis orders"
      - "Find customer Sarah Johnson's purchases"
      - "Show me what customer Robert Williams bought"
    parameters:
      - name: customer_name
        type: string
        description: "Customer name to search for"
        required: true
        aliases: ["name", "client_name", "buyer_name"]
      - name: days_back
        type: integer
        description: "Number of days to look back"
        required: false
        default: 365
    sql_template: |
      SELECT o.*, c.name as customer_name, c.email as customer_email
      FROM orders o
      JOIN customers c ON o.customer_id = c.id
      WHERE LOWER(c.name) LIKE LOWER(%(customer_name)s)
        AND o.order_date >= CURRENT_DATE - INTERVAL '%(days_back)s days'
      ORDER BY o.order_date DESC
      LIMIT 100
    result_format: "table"
    tags: ["order", "customer", "name", "search", "person"]
    semantic_tags:
      action: "find_list"
      primary_entity: "order"
      secondary_entity: "customer"
      qualifiers: ["by_name", "by_person_name", "customer_name"]
    approved: true

  - id: find_order_by_customer_name_recent
    version: "1.0.0"
    description: "Find recent orders for a customer by their name within a specific time period"
    nl_examples:
      - "Show me orders from John Smith in the last 3 days"
      - "What did Jane Doe order this week?"
      - "Find all orders from Bob Johnson within the last 7 days"
      - "Recent orders from Alice Wilson"
      - "I'm looking for all orders from Shelia Olson within the last 3 days"
    parameters:
      - name: customer_name
        type: string
        description: "Customer name to search for"
        required: true
        aliases: ["name", "client_name", "buyer_name"]
      - name: days_back
        type: integer
        description: "Number of days to look back"
        required: true
    sql_template: |
      SELECT o.*, c.name as customer_name, c.email as customer_email, c.city as customer_city
      FROM orders o
      JOIN customers c ON o.customer_id = c.id
      WHERE LOWER(c.name) LIKE LOWER(%(customer_name)s)
        AND o.order_date >= CURRENT_DATE - INTERVAL '%(days_back)s days'
      ORDER BY o.order_date DESC
      LIMIT 100
    result_format: "table"
    tags: ["order", "customer", "name", "search", "recent", "time"]
    semantic_tags:
      action: "find_list"
      primary_entity: "order"
      secondary_entity: "customer"
      qualifiers: ["by_name", "recent"]
    approved: true

  - id: list_customers_by_time_period
    version: "1.0.0"
    description: "List all customers who placed orders within a specific time period"
    nl_examples:
      - "Who ordered from us last week?"
      - "Which customers placed orders this month?"
      - "Show me all customers who ordered in the last 7 days"
      - "Who are the customers that ordered recently?"
      - "List customers who made purchases last week"
      - "Which customers bought from us this week?"
      - "Show me recent customers"
      - "Who ordered in the past few days?"
      - "Who has been ordering from us?"
      - "List of customers who ordered"
      - "Show customers who placed orders"
      - "Who are our recent customers?"
      - "Who are the customers who ordered?"
      - "Who placed orders with us?"
      - "Who bought from us recently?"
      - "Who are the people who ordered?"
    parameters:
      - name: days_back
        type: integer
        description: "Number of days to look back"
        required: true
        default: 7
        aliases: ["time_period", "days", "period"]
    sql_template: |
      SELECT DISTINCT c.id as customer_id, c.name as customer_name, c.email as customer_email, 
             c.city as customer_city, c.country as customer_country,
             COUNT(o.id) as order_count,
             SUM(o.total) as total_spent,
             MAX(o.order_date) as last_order_date,
             MIN(o.order_date) as first_order_date
      FROM customers c
      JOIN orders o ON c.id = o.customer_id
      WHERE o.order_date >= CURRENT_DATE - INTERVAL '%(days_back)s days'
      GROUP BY c.id, c.name, c.email, c.city, c.country
      ORDER BY last_order_date DESC, total_spent DESC
      LIMIT 100
    result_format: "table"
    tags: ["customer", "list", "time", "period", "recent", "who", "ordered"]
    semantic_tags:
      action: "list_who"
      primary_entity: "customer"
      secondary_entity: "order"
      qualifiers: ["by_time_period", "recent", "who_ordered"]
    approved: true

  - id: find_order_by_customer_id
    version: "1.0.0"
    description: "Find orders for a customer by their ID"
    nl_examples:
      - "What did customer 1 buy last week?"
      - "Show orders for customer ID 5"
      - "Find orders from customer #10"
      - "Customer 123 orders"
      - "Get purchases for customer number 7"
    parameters:
      - name: customer_id
        type: integer
        description: "Customer ID to search for"
        required: true
        aliases: ["id", "customer_number", "customer_num"]
      - name: days_back
        type: integer
        description: "Number of days to look back"
        required: false
        default: 365
    sql_template: |
      SELECT o.*, c.name as customer_name, c.email as customer_email
      FROM orders o
      JOIN customers c ON o.customer_id = c.id
      WHERE c.id = %(customer_id)s
        AND o.order_date >= CURRENT_DATE - INTERVAL '%(days_back)s days'
      ORDER BY o.order_date DESC
      LIMIT 100
    result_format: "table"
    tags: ["order", "customer", "id", "search"]
    semantic_tags:
      action: "find_list"
      primary_entity: "order"
      secondary_entity: "customer"
      qualifiers: ["by_id"]
    approved: true

  - id: find_high_value_orders_time_period
    version: "1.0.0"
    description: "Find orders above a specific amount within a time period"
    nl_examples:
      - "Show me all orders over $500 from last month"
      - "Find expensive orders above $1000"
      - "List high-value orders from the last 30 days"
      - "Orders worth more than $750 this week"
      - "Which orders exceeded $2000 last quarter?"
      - "Give me orders greater than $1200 from past 60 days"
    parameters:
      - name: min_amount
        type: decimal
        description: "Minimum order amount"
        required: true
        aliases: ["amount", "value", "threshold"]
      - name: days_back
        type: integer
        description: "Number of days to look back"
        required: false
        default: 30
    sql_template: |
      SELECT o.*, c.name as customer_name, c.email as customer_email
      FROM orders o
      JOIN customers c ON o.customer_id = c.id
      WHERE o.total > %(min_amount)s
        AND o.order_date >= CURRENT_DATE - INTERVAL '%(days_back)s days'
      ORDER BY o.total DESC, o.order_date DESC
      LIMIT 100
    result_format: "table"
    tags: ["order", "amount", "value", "high", "expensive", "time"]
    semantic_tags:
      action: "find_list"
      primary_entity: "order"
      qualifiers: ["by_amount", "by_time_period"]
    approved: true

  - id: find_high_value_orders
    version: "1.0.0"
    description: "Find all orders above a specific amount"
    nl_examples:
      - "Find expensive orders above $1000"
      - "Show orders worth more than $750"
      - "Which orders exceeded $2000?"
      - "Give me the premium orders over $1500"
      - "Large transactions above $800 please"
      - "Find all big ticket items over $600"
      - "Orders greater than $1200"
    parameters:
      - name: min_amount
        type: decimal
        description: "Minimum order amount"
        required: true
        aliases: ["amount", "value", "threshold"]
    sql_template: |
      SELECT o.*, c.name as customer_name, c.email as customer_email
      FROM orders o
      JOIN customers c ON o.customer_id = c.id
      WHERE o.total > %(min_amount)s
      ORDER BY o.total DESC, o.order_date DESC
      LIMIT 100
    result_format: "table"
    tags: ["order", "amount", "value", "high", "expensive", "premium", "large"]
    semantic_tags:
      action: "find_list"
      primary_entity: "order"
      qualifiers: ["by_amount"]
    approved: true

  - id: find_biggest_orders_recent
    version: "1.0.0"
    description: "Find the highest value orders from recent time period"
    nl_examples:
      - "What are the biggest orders recently?"
      - "Show me the largest orders this month"
      - "Top orders by value from last week"
      - "Highest value transactions lately"
      - "Recent big orders"
    parameters:
      - name: days_back
        type: integer
        description: "Number of days to look back"
        required: false
        default: 30
      - name: limit
        type: integer
        description: "Number of orders to return"
        required: false
        default: 20
    sql_template: |
      SELECT o.*, c.name as customer_name, c.email as customer_email
      FROM orders o
      JOIN customers c ON o.customer_id = c.id
      WHERE o.order_date >= CURRENT_DATE - INTERVAL '%(days_back)s days'
      ORDER BY o.total DESC
      LIMIT %(limit)s
    result_format: "table"
    tags: ["order", "biggest", "largest", "top", "high", "recent"]
    semantic_tags:
      action: "find_top"
      primary_entity: "order"
      qualifiers: ["by_amount", "recent"]
    approved: true

  - id: find_low_value_orders_time_period
    version: "1.0.0"
    description: "Find orders below a specific amount within a time period"
    nl_examples:
      - "Show me all orders under $500 from last month"
      - "Find cheap orders below $100"
      - "List low-value orders from the last 30 days"
      - "Orders worth less than $250 this week"
      - "Find all orders below $500 in the last 20 days"
      - "Small purchases under $50 from past week"
    parameters:
      - name: max_amount
        type: decimal
        description: "Maximum order amount"
        required: true
        aliases: ["amount", "value", "threshold", "limit"]
      - name: days_back
        type: integer
        description: "Number of days to look back"
        required: false
        default: 30
    sql_template: |
      SELECT o.*, c.name as customer_name, c.email as customer_email
      FROM orders o
      JOIN customers c ON o.customer_id = c.id
      WHERE o.total < %(max_amount)s
        AND o.order_date >= CURRENT_DATE - INTERVAL '%(days_back)s days'
      ORDER BY o.total ASC, o.order_date DESC
      LIMIT 100
    result_format: "table"
    tags: ["order", "amount", "value", "low", "cheap", "small", "under", "below", "time"]
    semantic_tags:
      action: "find_list"
      primary_entity: "order"
      qualifiers: ["by_amount", "by_time_period", "low_value"]
    approved: true

  - id: find_orders_below_amount
    version: "1.0.0"
    description: "Find all orders below/under a specific dollar amount"
    nl_examples:
      - "Show me the tiny transactions below $25"
      - "Find orders below $100"
      - "Show all orders under $50"
      - "Find cheap orders below $100"
      - "Show orders worth less than $250"
      - "Small purchases under $50"
      - "Budget orders less than $75"
      - "Orders smaller than $150"
      - "Low value orders under $200"
      - "Transactions below $500"
      - "Orders less than $25"
    parameters:
      - name: max_amount
        type: decimal
        description: "Maximum order amount"
        required: true
        aliases: ["amount", "value", "threshold", "limit"]
    sql_template: |
      SELECT o.*, c.name as customer_name, c.email as customer_email
      FROM orders o
      JOIN customers c ON o.customer_id = c.id
      WHERE o.total < %(max_amount)s
      ORDER BY o.total ASC, o.order_date DESC
      LIMIT 100
    result_format: "table"
    tags: ["order", "amount", "value", "low", "cheap", "small", "tiny", "budget", "under", "below", "less"]
    semantic_tags:
      action: "find_list"
      primary_entity: "order"
      qualifiers: ["by_amount", "low_value"]
    approved: true

  - id: find_smallest_orders_recent
    version: "1.0.0"
    description: "Find the lowest value orders from recent time period"
    nl_examples:
      - "What are the smallest orders recently?"
      - "Show me the cheapest orders this month"
      - "Bottom orders by value from last week"
      - "Lowest value transactions lately"
      - "Recent small orders"
      - "Tiny orders from the past few days"
    parameters:
      - name: days_back
        type: integer
        description: "Number of days to look back"
        required: false
        default: 30
      - name: limit
        type: integer
        description: "Number of orders to return"
        required: false
        default: 20
    sql_template: |
      SELECT o.*, c.name as customer_name, c.email as customer_email
      FROM orders o
      JOIN customers c ON o.customer_id = c.id
      WHERE o.order_date >= CURRENT_DATE - INTERVAL '%(days_back)s days'
      ORDER BY o.total ASC
      LIMIT %(limit)s
    result_format: "table"
    tags: ["order", "smallest", "cheapest", "bottom", "low", "recent", "tiny"]
    semantic_tags:
      action: "find_bottom"
      primary_entity: "order"
      qualifiers: ["by_amount", "recent", "smallest"]
    approved: true

  - id: find_orders_between_amounts
    version: "1.0.0"
    description: "Find orders between two specific amounts"
    nl_examples:
      - "Show orders between $100 and $500"
      - "Find orders from $50 to $200"
      - "Orders between $1000 and $5000"
      - "Show me orders in the range of $100 to $300"
      - "Find all orders between $250 and $750"
      - "Orders priced between $20 and $100"
    parameters:
      - name: min_amount
        type: decimal
        description: "Minimum order amount"
        required: true
        aliases: ["from", "starting", "minimum"]
      - name: max_amount
        type: decimal
        description: "Maximum order amount"
        required: true
        aliases: ["to", "ending", "maximum"]
    sql_template: |
      SELECT o.*, c.name as customer_name, c.email as customer_email
      FROM orders o
      JOIN customers c ON o.customer_id = c.id
      WHERE o.total >= %(min_amount)s
        AND o.total <= %(max_amount)s
      ORDER BY o.total ASC, o.order_date DESC
      LIMIT 100
    result_format: "table"
    tags: ["order", "amount", "between", "range", "from", "to"]
    semantic_tags:
      action: "find_list"
      primary_entity: "order"
      qualifiers: ["by_amount_range", "between"]
    approved: true

  - id: find_orders_by_status
    version: "1.0.0"
    description: "Find orders by their current status"
    nl_examples:
      - "Show me all pending orders"
      - "What orders are still processing?"
      - "Which orders are waiting to be processed?"
      - "Orders that have been delivered"
      - "Show me the cancelled transactions"
      - "What's in pending status?"
      - "Find all shipped packages"
      - "Orders currently being processed"
      - "Show completed deliveries"
      - "Which orders are cancelled?"
    parameters:
      - name: status
        type: enum
        description: "Order status to filter by"
        required: true
        allowed_values: ["pending", "processing", "shipped", "delivered", "cancelled"]
        aliases: ["order_status", "state"]
    sql_template: |
      SELECT o.*, c.name as customer_name, c.email as customer_email
      FROM orders o
      JOIN customers c ON o.customer_id = c.id
      WHERE o.status = %(status)s
      ORDER BY o.order_date DESC
      LIMIT 100
    result_format: "table"
    tags: ["order", "status", "pending", "processing", "shipped", "delivered", "cancelled", "state"]
    semantic_tags:
      action: "filter_by"
      primary_entity: "order"
      qualifiers: ["by_status"]
    approved: true

  - id: find_orders_by_status_time_period
    version: "1.0.0"
    description: "Find orders by status within a specific time period"
    nl_examples:
      - "Find delivered orders from last week"
      - "List cancelled orders from the last month"
      - "Show shipped orders from yesterday"
      - "Find processing orders from this week"
      - "Show me all delivered orders from last month"
      - "Pending orders from the last 3 days"
      - "Cancelled orders this week"
      - "Show processing orders from past 7 days"
    parameters:
      - name: status
        type: enum
        description: "Order status to filter by"
        required: true
        allowed_values: ["pending", "processing", "shipped", "delivered", "cancelled"]
        aliases: ["order_status", "state"]
      - name: days_back
        type: integer
        description: "Number of days to look back"
        required: false
        default: 7
    sql_template: |
      SELECT o.*, c.name as customer_name, c.email as customer_email
      FROM orders o
      JOIN customers c ON o.customer_id = c.id
      WHERE o.status = %(status)s
        AND o.order_date >= CURRENT_DATE - INTERVAL '%(days_back)s days'
      ORDER BY o.order_date DESC
      LIMIT 100
    result_format: "table"
    tags: ["order", "status", "time", "period", "pending", "processing", "shipped", "delivered", "cancelled"]
    semantic_tags:
      action: "filter_by"
      primary_entity: "order"
      qualifiers: ["by_status", "by_time_period"]
    approved: true

  - id: find_orders_by_exact_date
    version: "1.0.0"
    description: "Find orders placed on a specific exact date"
    nl_examples:
      - "Show me orders on July 20th 2025"
      - "Find orders from 25/07/2025"
      - "Orders placed on 2025-07-20"
      - "What orders were made on July 25, 2025?"
      - "Show orders from 07/20/2025"
      - "Find all orders on 20-07-2025"
      - "Orders on July 20"
      - "Show me what happened on 2025-07-25"
    parameters:
      - name: order_date
        type: date
        description: "Exact date to search for orders (YYYY-MM-DD format)"
        required: true
        aliases: ["date", "on_date", "specific_date"]
        example: "2025-07-20"
    sql_template: |
      SELECT o.*, c.name as customer_name, c.email as customer_email
      FROM orders o
      JOIN customers c ON o.customer_id = c.id
      WHERE DATE(o.order_date) = %(order_date)s
      ORDER BY o.order_date DESC, o.total DESC
      LIMIT 100
    result_format: "table"
    tags: ["order", "date", "exact", "specific", "on", "July", "day"]
    semantic_tags:
      action: "find_list"
      primary_entity: "order"
      qualifiers: ["by_exact_date"]
    approved: true

  - id: find_orders_by_amount_and_date
    version: "1.0.0"
    description: "Find orders above/below a specific amount on an exact date"
    nl_examples:
      - "Show me orders above $500 on July 20th 2025"
      - "Find orders over $1000 from 25/07/2025"
      - "Orders above $100 placed on 2025-07-20"
      - "Show orders under $50 on July 25, 2025"
      - "Find expensive orders over $500 from 07/20/2025"
      - "Orders below $200 on 20-07-2025"
      - "High value orders above $1000 on July 20"
    parameters:
      - name: order_date
        type: date
        description: "Exact date to search for orders (YYYY-MM-DD format)"
        required: true
        aliases: ["date", "on_date", "specific_date"]
        example: "2025-07-20"
      - name: min_amount
        type: decimal
        description: "Minimum order amount (use for 'above/over' queries)"
        required: false
        aliases: ["above", "over", "greater_than", "minimum"]
      - name: max_amount
        type: decimal
        description: "Maximum order amount (use for 'below/under' queries)"
        required: false
        aliases: ["below", "under", "less_than", "maximum"]
    sql_template: |
      SELECT o.*, c.name as customer_name, c.email as customer_email
      FROM orders o
      JOIN customers c ON o.customer_id = c.id
      WHERE DATE(o.order_date) = %(order_date)s
        AND (
          (%(min_amount)s IS NOT NULL AND o.total >= %(min_amount)s) OR
          (%(max_amount)s IS NOT NULL AND o.total <= %(max_amount)s) OR
          (%(min_amount)s IS NULL AND %(max_amount)s IS NULL)
        )
      ORDER BY o.order_date DESC, o.total DESC
      LIMIT 100
    result_format: "table"
    tags: ["order", "date", "exact", "amount", "above", "below", "over", "under", "July", "expensive", "cheap"]
    semantic_tags:
      action: "find_list"
      primary_entity: "order"
      qualifiers: ["by_exact_date", "by_amount"]
    approved: true

  - id: calculate_customer_lifetime_value_by_id
    version: "1.0.0"
    description: "Calculate lifetime value and statistics for a customer by their ID"
    nl_examples:
      - "What's the lifetime value of customer 123?"
      - "How much has customer 456 spent in total?"
      - "Show me the total revenue from customer 89"
      - "Calculate customer 12's lifetime spending"
      - "What's customer 567's total purchase amount?"
      - "How valuable is customer 234 to us?"
      - "Total sales to customer 890"
      - "Customer 345 lifetime statistics"
      - "Give me a summary for customer 123"
      - "What's the total spent by customer 4124?"
      - "How much has customer 1001 spent?"
      - "Customer 9999 total spending"
      - "Show analytics for customer 2050"
      - "Customer ID 789 lifetime value"
      - "Total revenue from customer number 555"
    parameters:
      - name: customer_id
        type: integer
        description: "Customer ID to analyze"
        required: true
        aliases: ["id", "customer_number", "customer_num"]
    sql_template: |
      SELECT 
        c.id as customer_id,
        c.name as customer_name,
        c.email as customer_email,
        c.city as customer_city,
        c.country as customer_country,
        c.created_at as customer_since,
        COUNT(o.id) as total_orders,
        COALESCE(SUM(o.total), 0) as lifetime_value,
        COALESCE(AVG(o.total), 0) as average_order_value,
        COALESCE(MIN(o.total), 0) as smallest_order,
        COALESCE(MAX(o.total), 0) as largest_order,
        MIN(o.order_date) as first_order_date,
        MAX(o.order_date) as last_order_date,
        COUNT(CASE WHEN o.status = 'pending' THEN 1 END) as pending_orders,
        COUNT(CASE WHEN o.status = 'processing' THEN 1 END) as processing_orders,
        COUNT(CASE WHEN o.status = 'shipped' THEN 1 END) as shipped_orders,
        COUNT(CASE WHEN o.status = 'delivered' THEN 1 END) as delivered_orders,
        COUNT(CASE WHEN o.status = 'cancelled' THEN 1 END) as cancelled_orders
      FROM customers c
      LEFT JOIN orders o ON c.id = o.customer_id
      WHERE c.id = %(customer_id)s
      GROUP BY c.id, c.name, c.email, c.city, c.country, c.created_at
    result_format: "summary"
    tags: ["customer", "analytics", "lifetime", "value", "total", "spending", "revenue", "statistics", "summary", "id", "number", "4124", "1001", "9999", "numeric"]
    semantic_tags:
      action: "calculate_summary"
      primary_entity: "customer"
      qualifiers: ["lifetime_value", "by_id"]
    approved: true

  - id: calculate_customer_lifetime_value_by_name
    version: "1.0.0"
    description: "Calculate lifetime value and statistics for a customer by their name"
    nl_examples:
      - "What's the total spent by customer John Doe?"
      - "How much has Maria Smith spent in total?"
      - "Show me the lifetime value of Sarah Connor"
      - "Calculate John Smith's total spending"
      - "What's Jane Wilson's purchase history summary?"
      - "How valuable is Robert Johnson to us?"
      - "Total revenue from Michael Brown"
      - "Jessica Davis lifetime statistics"
    parameters:
      - name: customer_name
        type: string
        description: "Customer name to search for"
        required: true
        aliases: ["name", "client_name", "buyer_name"]
    sql_template: |
      SELECT 
        c.id as customer_id,
        c.name as customer_name,
        c.email as customer_email,
        c.city as customer_city,
        c.country as customer_country,
        c.created_at as customer_since,
        COUNT(o.id) as total_orders,
        COALESCE(SUM(o.total), 0) as lifetime_value,
        COALESCE(AVG(o.total), 0) as average_order_value,
        COALESCE(MIN(o.total), 0) as smallest_order,
        COALESCE(MAX(o.total), 0) as largest_order,
        MIN(o.order_date) as first_order_date,
        MAX(o.order_date) as last_order_date,
        COUNT(CASE WHEN o.status = 'pending' THEN 1 END) as pending_orders,
        COUNT(CASE WHEN o.status = 'processing' THEN 1 END) as processing_orders,
        COUNT(CASE WHEN o.status = 'shipped' THEN 1 END) as shipped_orders,
        COUNT(CASE WHEN o.status = 'delivered' THEN 1 END) as delivered_orders,
        COUNT(CASE WHEN o.status = 'cancelled' THEN 1 END) as cancelled_orders
      FROM customers c
      LEFT JOIN orders o ON c.id = o.customer_id
      WHERE LOWER(c.name) LIKE LOWER(%(customer_name)s)
      GROUP BY c.id, c.name, c.email, c.city, c.country, c.created_at
      ORDER BY lifetime_value DESC
      LIMIT 10
    result_format: "summary"
    tags: ["customer", "analytics", "lifetime", "value", "total", "spending", "revenue", "statistics", "name", "summary"]
    semantic_tags:
      action: "calculate_summary"
      primary_entity: "customer"
      qualifiers: ["lifetime_value", "by_name"]
    approved: true

  - id: customer_spending_analysis_by_numeric_id
    version: "1.0.0"
    description: "Analyze customer spending and value by numeric customer ID"
    nl_examples:
      - "What's the total spent by customer 4124?"
      - "How much has customer 1001 spent?"
      - "Customer 9999 total spending"
      - "Show spending for customer 2050"
      - "Customer 789 analytics"
      - "Total from customer number 555"
      - "Customer ID 3456 lifetime value"
      - "How much did customer 7890 spend?"
      - "Customer 1234 revenue analysis"
      - "Spending summary for customer 5678"
    parameters:
      - name: customer_id
        type: integer
        description: "Numeric customer ID to analyze"
        required: true
        aliases: ["id", "customer_number", "number", "numeric_id"]
    sql_template: |
      SELECT 
        c.id as customer_id,
        c.name as customer_name,
        c.email as customer_email,
        COUNT(o.id) as total_orders,
        COALESCE(SUM(o.total), 0) as total_spent,
        COALESCE(AVG(o.total), 0) as average_order_value,
        MAX(o.order_date) as last_order_date
      FROM customers c
      LEFT JOIN orders o ON c.id = o.customer_id
      WHERE c.id = %(customer_id)s
      GROUP BY c.id, c.name, c.email
    result_format: "summary"
    tags: ["customer", "spending", "total", "numeric", "id", "4124", "1001", "9999", "2050", "analytics", "number"]
    semantic_tags:
      action: "calculate_summary"
      primary_entity: "customer"
      qualifiers: ["spending_analysis", "numeric_id"]
    approved: true

  - id: find_orders_by_customer_city
    version: "1.0.0"
    description: "Find orders from customers in a specific city or location"
    nl_examples:
      - "Show orders from customers in New York"
      - "Find orders from customers located in Los Angeles"  
      - "What orders came from the city of Chicago?"
      - "Orders from customers in San Francisco"
      - "Show me orders from customers in the city of Boston"
      - "Which customers from the city of Seattle ordered?"
      - "Orders from customers in Dallas city"
      - "Find purchases from customers in Miami"
      - "Orders originating from customers in Denver"
      - "Show transactions from customers in Houston"
      - "Orders from customers located in Phoenix"
      - "Customer orders from the city of Atlanta"
      - "Purchases from customers in Las Vegas"
      - "Orders from customers located in Toronto"
      - "Show me customers from the city of Montreal"
    parameters:
      - name: city
        type: string
        description: "City name to filter customers by"
        required: true
        aliases: ["customer_city", "location", "from_city"]
    sql_template: |
      SELECT o.*, c.name as customer_name, c.email as customer_email, 
             c.city as customer_city, c.country as customer_country
      FROM orders o
      JOIN customers c ON o.customer_id = c.id
      WHERE LOWER(c.city) LIKE LOWER(%(city)s)
      ORDER BY o.order_date DESC
      LIMIT 100
    result_format: "table"
    tags: ["order", "customer", "city", "location", "geographic", "New York", "Los Angeles", "Chicago", "San Francisco", "Boston", "Seattle", "Dallas", "Miami", "Denver", "Houston"]
    semantic_tags:
      action: "find_list"
      primary_entity: "order"
      secondary_entity: "customer"
      qualifiers: ["by_customer_city", "geographic"]
    approved: true

  - id: find_customers_by_city_who_ordered
    version: "1.0.0"
    description: "Find customers from a specific city who have placed orders"
    nl_examples:
      - "Which customers from Seattle ordered?"
      - "Show me customers from New York who made purchases"
      - "List customers from Chicago with orders"
      - "Who are the customers from Miami that ordered?"
      - "Boston customers who have purchased"
      - "Denver customers with orders"
      - "Show active customers from Dallas"
    parameters:
      - name: city
        type: string
        description: "City name to filter customers by"
        required: true
        aliases: ["customer_city", "location", "from_city"]
    sql_template: |
      SELECT DISTINCT c.id as customer_id, c.name as customer_name, 
             c.email as customer_email, c.city as customer_city, 
             c.country as customer_country,
             COUNT(o.id) as total_orders,
             SUM(o.total) as total_spent,
             MAX(o.order_date) as last_order_date
      FROM customers c
      JOIN orders o ON c.id = o.customer_id
      WHERE LOWER(c.city) LIKE LOWER(%(city)s)
      GROUP BY c.id, c.name, c.email, c.city, c.country
      ORDER BY total_spent DESC, last_order_date DESC
      LIMIT 50
    result_format: "table"
    tags: ["customer", "city", "location", "geographic", "who", "ordered", "purchased", "Seattle", "New York", "Chicago", "Miami", "Boston", "Denver", "Dallas"]
    semantic_tags:
      action: "find_list"
      primary_entity: "customer"
      qualifiers: ["by_city", "who_ordered", "geographic"]
    approved: true

  - id: find_top_buyers_by_spending
    version: "1.0.0"
    description: "Find the top customers/buyers ranked by total spending amount"
    nl_examples:
      - "Show me the Top 5 buyers please"
      - "Who are our top 10 customers?"
      - "Find the biggest spenders"
      - "Show me the top customers by spending"
      - "Who are our best buyers?"
      - "Top 5 customers by revenue"
      - "Show the highest spending customers"
      - "Find our most valuable customers"
      - "Top buyers by total purchases"
      - "Show me the top 3 spenders"
      - "Who spent the most?"
      - "Best customers by lifetime value"
    parameters:
      - name: limit
        type: integer
        description: "Number of top customers to return"
        required: false
        default: 10
        aliases: ["top", "count", "number"]
    sql_template: |
      SELECT 
        c.id as customer_id,
        c.name as customer_name,
        c.email as customer_email,
        c.city as customer_city,
        c.country as customer_country,
        COUNT(o.id) as total_orders,
        SUM(o.total) as total_spent,
        AVG(o.total) as average_order_value,
        MAX(o.order_date) as last_order_date,
        MIN(o.order_date) as first_order_date
      FROM customers c
      JOIN orders o ON c.id = o.customer_id
      GROUP BY c.id, c.name, c.email, c.city, c.country
      ORDER BY total_spent DESC
      LIMIT %(limit)s
    result_format: "table"
    tags: ["customer", "top", "buyers", "best", "highest", "spending", "spenders", "valuable", "revenue", "biggest", "most"]
    semantic_tags:
      action: "rank_list"
      primary_entity: "customer"
      qualifiers: ["top_by_spending", "buyers"]
    approved: true

  - id: find_customer_by_email
    version: "1.0.0"
    description: "Find customer information by their email address"
    nl_examples:
      - "Find customer with email john@example.com"
      - "Search for user@gmail.com"
      - "Who has the email address sarah@company.com?"
      - "Customer with email mike@domain.org"
      - "Look up buyer@email.net"
      - "Find customer mary@test.com"
      - "Search for admin@business.org"
      - "Who owns email contact@store.com?"
      - "Customer lookup for info@client.net"
      - "Find user with email address support@website.com"
      - "Look up sescudero202507220947037871@oscuro.org please"
      - "look up sescudero202507220947037871 oscuro org please"
      - "Find customer john example com"
      - "Search for user gmail com"
      - "Look up customer email without symbols"
    parameters:
      - name: email
        type: string
        description: "Customer email address to search for"
        required: true
        aliases: ["email_address", "customer_email", "user_email"]
        pattern: "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$"
    sql_template: |
      SELECT 
        c.id as customer_id,
        c.name as customer_name,
        c.email as customer_email,
        c.phone as customer_phone,
        c.city as customer_city,
        c.country as customer_country,
        c.created_at as customer_since,
        COUNT(o.id) as total_orders,
        COALESCE(SUM(o.total), 0) as total_spent,
        MAX(o.order_date) as last_order_date
      FROM customers c
      LEFT JOIN orders o ON c.id = o.customer_id
      WHERE LOWER(c.email) = LOWER(%(email)s)
      GROUP BY c.id, c.name, c.email, c.phone, c.city, c.country, c.created_at
    result_format: "summary"
    tags: ["customer", "email", "search", "lookup", "find", "@", "gmail", "domain", "address", "oscuro", "org", "sescudero", "com", "net"]
    semantic_tags:
      action: "search_find"
      primary_entity: "customer"
      qualifiers: ["by_email"]
    approved: true

  - id: find_inactive_dormant_customers
    version: "1.0.0"
    description: "Find customers who haven't placed orders recently (inactive/dormant customers)"
    nl_examples:
      - "Show inactive customers"
      - "Who hasn't ordered in 90 days?"
      - "Find dormant customers"
      - "Customers not buying recently"
      - "Show me who stopped ordering"
      - "Who hasn't ordered in 6 months?"
      - "Find customers who stopped buying"
      - "Show dormant customers from last 3 months"
      - "Inactive customers who haven't purchased"
      - "Customers who haven't ordered lately"
      - "Show me customers who went quiet"
      - "Find customers who stopped purchasing"
    parameters:
      - name: days_inactive
        type: integer
        description: "Number of days of inactivity to consider dormant"
        required: false
        default: 90
        aliases: ["days", "inactive_days", "dormant_period", "days_back"]
    sql_template: |
      SELECT DISTINCT
        c.id as customer_id,
        c.name as customer_name,
        c.email as customer_email,
        c.city as customer_city,
        c.country as customer_country,
        c.created_at as customer_since,
        COUNT(o.id) as total_orders,
        COALESCE(SUM(o.total), 0) as total_spent,
        MAX(o.order_date) as last_order_date,
        CURRENT_DATE - MAX(o.order_date) as days_since_last_order
      FROM customers c
      LEFT JOIN orders o ON c.id = o.customer_id
      WHERE c.id NOT IN (
        SELECT DISTINCT customer_id
        FROM orders
        WHERE order_date >= CURRENT_DATE - INTERVAL '%(days_inactive)s days'
      )
      GROUP BY c.id, c.name, c.email, c.city, c.country, c.created_at
      ORDER BY last_order_date ASC NULLS LAST
      LIMIT 100
    result_format: "table"
    tags: ["customer", "inactive", "dormant", "stopped", "not", "buying", "ordering", "quiet", "90", "days", "months"]
    semantic_tags:
      action: "find_list"
      primary_entity: "customer"
      qualifiers: ["inactive", "dormant", "not_recent"]
    approved: true

  - id: find_orders_by_shipping_country
    version: "1.0.0"
    description: "Find orders by their shipping destination country"
    nl_examples:
      - "Show orders shipped to the United States"
      - "Orders delivered to European countries"
      - "Shipping to Asian countries"
      - "Canadian customers shipping abroad"
      - "Orders with international shipping addresses"
      - "Show me international shipments"
      - "Orders shipped outside Canada"
      - "International delivery orders"
      - "Cross-border orders"
      - "Orders shipped to France"
      - "Show deliveries to Germany"
      - "Orders going to Japan"
    parameters:
      - name: shipping_country
        type: string
        description: "Shipping destination country"
        required: true
        aliases: ["country", "destination", "shipped_to"]
    sql_template: |
      SELECT o.*, c.name as customer_name, c.email as customer_email,
             c.city as customer_city, c.country as customer_country
      FROM orders o
      JOIN customers c ON o.customer_id = c.id
      WHERE LOWER(c.country) LIKE LOWER(%(shipping_country)s)
      ORDER BY o.order_date DESC
      LIMIT 100
    result_format: "table"
    tags: ["order", "shipping", "country", "international", "delivered", "abroad", "cross-border", "United States", "European", "Asian", "Canadian", "France", "Germany", "Japan"]
    semantic_tags:
      action: "find_list"
      primary_entity: "order"
      qualifiers: ["by_shipping_country", "international"]
    approved: true

  - id: find_international_orders_by_amount
    version: "1.0.0"
    description: "Find international orders above a specific amount"
    nl_examples:
      - "International orders over $200"
      - "Show international orders above $500"
      - "Cross-border orders over $100"
      - "International shipments above $1000"
      - "High-value international orders over $300"
      - "Expensive international deliveries above $250"
    parameters:
      - name: min_amount
        type: decimal
        description: "Minimum order amount for international orders"
        required: true
        aliases: ["amount", "over", "above", "minimum"]
      - name: exclude_country
        type: string
        description: "Country to exclude (typically home country)"
        required: false
        default: "Canada"
        aliases: ["home_country", "domestic"]
    sql_template: |
      SELECT o.*, c.name as customer_name, c.email as customer_email,
             c.city as customer_city, c.country as customer_country
      FROM orders o
      JOIN customers c ON o.customer_id = c.id
      WHERE o.total >= %(min_amount)s
        AND (c.country IS NOT NULL 
             AND LOWER(c.country) != LOWER(%(exclude_country)s))
      ORDER BY o.total DESC, o.order_date DESC
      LIMIT 100
    result_format: "table"
    tags: ["order", "international", "amount", "over", "above", "cross-border", "expensive", "high-value", "$200", "$500", "$100"]
    semantic_tags:
      action: "find_list"
      primary_entity: "order"
      qualifiers: ["international", "by_amount"]
    approved: true

  - id: find_international_vs_domestic_orders
    version: "1.0.0"
    description: "Find orders that are international (shipped outside home country)"
    nl_examples:
      - "Show me international shipments"
      - "Orders shipped outside Canada"
      - "International delivery orders"
      - "Cross-border orders"
      - "Show international orders only"
      - "Orders delivered internationally"
      - "Non-domestic shipments"
    parameters:
      - name: home_country
        type: string
        description: "Home country to compare against"
        required: false
        default: "Canada"
        aliases: ["domestic_country", "base_country"]
    sql_template: |
      SELECT o.*, c.name as customer_name, c.email as customer_email,
             c.city as customer_city, c.country as customer_country,
             CASE 
               WHEN LOWER(c.country) != LOWER(%(home_country)s) THEN 'International' 
               ELSE 'Domestic' 
             END as shipment_type
      FROM orders o
      JOIN customers c ON o.customer_id = c.id
      WHERE c.country IS NOT NULL 
        AND LOWER(c.country) != LOWER(%(home_country)s)
      ORDER BY o.order_date DESC
      LIMIT 100
    result_format: "table"
    tags: ["order", "international", "cross-border", "outside", "abroad", "non-domestic", "shipments", "delivery"]
    semantic_tags:
      action: "find_list"
      primary_entity: "order"
      qualifiers: ["international_only"]
    approved: true

  - id: find_new_customers_by_time_period
    version: "1.0.0"
    description: "Find new customers who registered within a specific time period"
    nl_examples:
      - "Show me new customers from Aug 1 2025"
      - "Who are the new customers this week?"
      - "Find customers who registered in the last 7 days"
      - "Show new customers from last month"
      - "List recently registered customers"
      - "New customers who joined this month"
      - "Show me customers who signed up recently"
      - "Find new customers from the past 3 days"
      - "Who registered in the last 30 days?"
      - "Show new customer registrations"
      - "Recent customer signups"
      - "New customers who joined us"
    parameters:
      - name: days_back
        type: integer
        description: "Number of days to look back from today"
        required: false
        default: 7
        aliases: ["days", "period", "time_period"]
    sql_template: |
      SELECT 
        c.id as customer_id,
        c.name as customer_name,
        c.email as customer_email,
        c.phone as customer_phone,
        c.city as customer_city,
        c.country as customer_country,
        c.created_at as registration_date,
        CURRENT_DATE - DATE(c.created_at) as days_since_registration,
        COUNT(o.id) as total_orders,
        COALESCE(SUM(o.total), 0) as total_spent
      FROM customers c
      LEFT JOIN orders o ON c.id = o.customer_id
      WHERE c.created_at >= CURRENT_DATE - INTERVAL '%(days_back)s days'
      GROUP BY c.id, c.name, c.email, c.phone, c.city, c.country, c.created_at
      ORDER BY c.created_at DESC
      LIMIT 100
    result_format: "table"
    tags: ["customer", "new", "registered", "joined", "signed", "recent", "registration", "signup"]
    semantic_tags:
      action: "find_list"
      primary_entity: "customer"
      qualifiers: ["new", "by_registration_date", "recent"]
    approved: true

  - id: find_new_customers_from_specific_date
    version: "1.0.0"
    description: "Find new customers who registered from a specific date onwards"
    nl_examples:
      - "Show me new customers from Aug 1 2025"
      - "Find customers who registered since July 15, 2025"
      - "New customers from 2025-08-01"
      - "Who registered after August 1st?"
      - "Show customers who joined since 08/01/2025"
      - "New customers from August 1st, 2025"
      - "Find registrations since Aug 1"
      - "Customers who signed up from August 1"
    parameters:
      - name: from_date
        type: date
        description: "Start date to find new customers from (YYYY-MM-DD format)"
        required: true
        aliases: ["start_date", "since_date", "from", "since"]
        example: "2025-08-01"
    sql_template: |
      SELECT 
        c.id as customer_id,
        c.name as customer_name,
        c.email as customer_email,
        c.phone as customer_phone,
        c.city as customer_city,
        c.country as customer_country,
        c.created_at as registration_date,
        CURRENT_DATE - DATE(c.created_at) as days_since_registration,
        COUNT(o.id) as total_orders,
        COALESCE(SUM(o.total), 0) as total_spent
      FROM customers c
      LEFT JOIN orders o ON c.id = o.customer_id
      WHERE DATE(c.created_at) >= %(from_date)s
      GROUP BY c.id, c.name, c.email, c.phone, c.city, c.country, c.created_at
      ORDER BY c.created_at DESC
      LIMIT 100
    result_format: "table"
    tags: ["customer", "new", "registered", "from", "since", "specific", "date", "Aug", "August", "July"]
    semantic_tags:
      action: "find_list"
      primary_entity: "customer"
      qualifiers: ["new", "from_specific_date"]
    approved: true