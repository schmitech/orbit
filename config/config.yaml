import:
  - "adapters.yaml"
  - "inference.yaml"
  - "datasources.yaml"
  - "embeddings.yaml"
  - "rerankers.yaml"
  - "stores.yaml"
  - "moderators.yaml"

general:
  port: 3000
  verbose: false
  https:
    enabled: false
    port: 3443
    cert_file: "./cert.pem"
    key_file: "./key.pem"
  session_id:
    header_name: "X-Session-ID"
    required: true
  inference_provider: "groq"
  inference_only: false

language_detection:
  enabled: false
  backends:
    - "langdetect"
    - "langid"
    - "pycld2"
  backend_weights:
    langdetect: 1.0
    langid: 1.2
    pycld2: 1.5
  min_confidence: 0.5
  min_margin: 0.1
  prefer_english_for_ascii: false
  enable_stickiness: false
  fallback_language: "en"

performance:
  workers: 4
  keep_alive_timeout: 30
  
  thread_pools:
    io_workers: 50              # Up from 10
    cpu_workers: 30             # CPU-bound tasks
    inference_workers: 20       # Model inference
    embedding_workers: 15       # Embedding generation
    db_workers: 25              # Database operations

fault_tolerance:
  circuit_breaker:
    failure_threshold: 5
    recovery_timeout: 30
    success_threshold: 3
    timeout: 30
    max_recovery_timeout: 300.0
    enable_exponential_backoff: true
  execution:
    strategy: "all"  # "all", "first_success", "best_effort"
    timeout: 35 
    max_retries: 3
    retry_delay: 1
  
messages:
  no_results_response: "I'm sorry, but I don't have any specific information about that topic in my knowledge base."
  collection_not_found: "I couldn't find the requested collection. Please make sure the collection exists before querying it."

auth:
  enabled: true
  session_duration_hours: 12
  default_admin_username: admin
  default_admin_password: ${ORBIT_DEFAULT_ADMIN_PASSWORD}
  pbkdf2_iterations: 600000
  # Credential storage method: "keyring" (default) or "file"
  # - keyring: Uses system keychain (macOS Keychain, Linux Secret Service)
  # - file: Uses plain text file in ~/.orbit/.env (less secure but visible)
  credential_storage: file

# Embedding configuration moved to embeddings.yaml

api_keys:
  header_name: "X-API-Key"
  prefix: "orbit_"

prompt_service:
  cache:
    ttl_seconds: 3600  # 1 hour - how long to cache prompts in Redis

logging:
  level: "INFO"
  handlers:
    file:
      enabled: true
      directory: "logs"
      filename: "orbit.log"
      max_size_mb: 10
      backup_count: 30
      rotation: "midnight"
      format: "text"
    console:
      enabled: false
      format: "text"
  capture_warnings: true
  propagate: false
  loggers:
    inference.clients.llama_cpp:
      level: "ERROR"
    llama_cpp:
      level: "ERROR"
    llama_cpp.llama:
      level: "ERROR"
    ggml:
      level: "ERROR"
    metal:
      level: "ERROR"

clock_service:
  enabled: true
  default_timezone: "America/Toronto"
  format: "%A, %B %d, %Y at %I:%M:%S %p %Z"

internal_services:
  elasticsearch:
    enabled: true
    node: ${INTERNAL_SERVICES_ELASTICSEARCH_NODE}
    index: 'orbit'
    username: ${INTERNAL_SERVICES_ELASTICSEARCH_USERNAME}
    password: ${INTERNAL_SERVICES_ELASTICSEARCH_PASSWORD}

  mongodb:
    host: ${INTERNAL_SERVICES_MONGODB_HOST}
    port: ${INTERNAL_SERVICES_MONGODB_PORT}
    username: ${INTERNAL_SERVICES_MONGODB_USERNAME}
    password: ${INTERNAL_SERVICES_MONGODB_PASSWORD}
    database: ${INTERNAL_SERVICES_MONGODB_DB}
    users_collection: users
    sessions_collection: sessions
    apikey_collection: api_keys
    prompts_collection: system_prompts

  redis:
    enabled: false
    host: ${INTERNAL_SERVICES_REDIS_HOST}
    port: ${INTERNAL_SERVICES_REDIS_PORT}
    db: 0
    username: ${INTERNAL_SERVICES_REDIS_USERNAME}
    password: ${INTERNAL_SERVICES_REDIS_PASSWORD}
    use_ssl: false
    ttl: 3600  # 1 hour, matching temp_key_expiry

chat_history:
  enabled: true
  collection_name: "chat_history"
  store_metadata: true
  retention_days: 90
  max_tracked_sessions: 10000
  session:
    auto_generate: false
    required: true
    header_name: "X-Session-ID"
  user:
    header_name: "X-User-ID"
    required: false

safety:
  enabled: false
  mode: "fuzzy"
  moderator: "ollama"
  max_retries: 3
  retry_delay: 1.0
  request_timeout: 10
  allow_on_timeout: false
  disable_on_fallback: true  # Disable safety if no moderators are available

llm_guard:
  enabled: false
  service:
    base_url: "http://localhost:8000"
    timeout: 30                 # Backward-compatible total timeout (seconds)
    # Optional fine-grained timeouts and resiliency settings
    connect_timeout: 5        # TCP connect timeout (seconds)
    read_timeout: 30          # Socket read timeout (seconds); defaults to `timeout`
    total_timeout: 30         # Session total timeout (seconds); defaults to `timeout`
    request_timeout: 10       # Per-request timeout (seconds); defaults to min(total_timeout, 10)

    # Retry behavior
    max_attempts: 2           # Number of attempts per request
    backoff_factor: 0.4       # Exponential backoff base for retries
    retry_status_codes:       # HTTP codes that should trigger retry
      - 500
      - 502
      - 503
      - 504

    # Health check settings
    health_interval: 30       # Seconds to cache positive health status
    health_timeout: 5         # Timeout for /health endpoint (seconds)

    # Circuit breaker
    failure_threshold: 3      # Consecutive failures before opening the circuit
    circuit_reset_timeout: 60 # Seconds to keep circuit open before retrying
  security:
    risk_threshold: 0.6
    # Scanner configurations for different content types
    scanners:
      prompt:  # Scanners for user input (prompts)
        - "ban_substrings"
        - "ban_topics" 
        - "prompt_injection"
        - "toxicity"
        - "secrets"
      response:  # Scanners for AI output (responses)
        - "no_refusal"
        - "sensitive"
        - "bias"
        - "relevance"
  fallback:
    on_error: "allow"

reranker:
  provider: "ollama"
  enabled: false

monitoring:
  enabled: true                    # Enable/disable monitoring dashboard
  metrics:
    collection_interval: 5         # Seconds between metric collections
    time_window: 300              # Seconds of historical data to keep (5 minutes)
    prometheus:
      enabled: true               # Enable Prometheus endpoint at /metrics
    dashboard:
      enabled: true               # Enable web dashboard at /dashboard
      websocket_update_interval: 5 # Seconds between WebSocket updates
  alerts:                         # Alert thresholds (future use)
    cpu_threshold: 90             # Alert when CPU > 90%
    memory_threshold: 85          # Alert when memory > 85%
    error_rate_threshold: 5       # Alert when error rate > 5%
    response_time_threshold: 5000 # Alert when avg response time > 5000ms
