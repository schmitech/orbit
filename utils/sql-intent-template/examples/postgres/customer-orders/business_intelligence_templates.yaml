templates:
  # Revenue and Growth Analysis
  - id: monthly_revenue_analysis
    version: "1.0.0"
    description: "Analyze monthly revenue trends and growth patterns"
    nl_examples:
      - "Show me monthly revenue for this year"
      - "What's our revenue trend by month?"
      - "Monthly sales performance analysis"
      - "Revenue growth by month"
      - "Show monthly revenue breakdown"
      - "How much revenue did we make each month?"
      - "Monthly revenue report"
    parameters:
      - name: year
        type: integer
        description: "Year to analyze (defaults to current year)"
        required: false
        default: 2025
    sql_template: |
      SELECT 
        EXTRACT(MONTH FROM o.order_date) as month,
        TRIM(TO_CHAR(o.order_date, 'Month')) as month_name,
        COUNT(o.id) as total_orders,
        SUM(o.total) as total_revenue,
        AVG(o.total) as average_order_value,
        COUNT(DISTINCT o.customer_id) as unique_customers
      FROM orders o
      WHERE EXTRACT(YEAR FROM o.order_date) = %(year)s
        AND o.status != 'cancelled'
      GROUP BY EXTRACT(MONTH FROM o.order_date), TO_CHAR(o.order_date, 'Month')
      ORDER BY month
    result_format: "table"
    tags: ["revenue", "monthly", "analysis", "trends", "growth", "sales", "performance"]
    semantic_tags:
      action: "analyze_trends"
      primary_entity: "revenue"
      qualifiers: ["monthly", "growth"]
    approved: true

  - id: daily_sales_summary # FIXME
    version: "1.0.0"
    description: "Daily sales summary and performance metrics"
    nl_examples:
      - "Show me today's sales"
      - "What were our sales yesterday?"
      - "Daily sales for the past week"
      - "How much did we sell today?"
      - "Today's revenue summary"
      - "Daily sales performance"
      - "Show me sales for August 4th 2025"
    parameters:
      - name: target_date
        type: date
        description: "Date to analyze (defaults to today)"
        required: false
        default: "TODAY"
        aliases: ["date", "day"]
      - name: days_range
        type: integer
        description: "Number of days to include (for range analysis)"
        required: false
        default: 1
    sql_template: |
      WITH input_params AS (
        SELECT 
          CASE 
            WHEN %(target_date)s = 'TODAY' THEN CURRENT_DATE
            WHEN %(target_date)s ~ '^\d{4}-\d{2}-\d{2}$' THEN to_date(%(target_date)s, 'YYYY-MM-DD')
            WHEN %(target_date)s ~ '^\d{2}/\d{2}/\d{4}$' THEN to_date(%(target_date)s, 'MM/DD/YYYY')
            WHEN %(target_date)s ~ '^\d{2}-\d{2}-\d{4}$' THEN to_date(%(target_date)s, 'MM-DD-YYYY')
            WHEN %(target_date)s ~ '^[A-Za-z]+ \d{1,2}[a-z]{0,2}(,? \d{4})?$' THEN
              to_date(
                REGEXP_REPLACE(
                  REGEXP_REPLACE(%(target_date)s, '(st|nd|rd|th)', '', 'gi'),
                  ',',
                  '',
                  'g'
                ) ||
                CASE 
                  WHEN %(target_date)s ~ '\d{4}' THEN ''
                  ELSE ' ' || EXTRACT(YEAR FROM CURRENT_DATE)::text
                END,
                'Month DD YYYY'
              )
            ELSE NULL
          END as target_date,
          GREATEST(COALESCE(%(days_range)s, 1), 1)::int as days_range
      )
      SELECT 
        DATE(o.order_date) as sale_date,
        COUNT(o.id) as total_orders,
        SUM(o.total) as total_revenue,
        AVG(o.total) as average_order_value,
        COUNT(DISTINCT o.customer_id) as unique_customers,
        MIN(o.total) as smallest_order,
        MAX(o.total) as largest_order
      FROM orders o
      CROSS JOIN input_params ip
      WHERE (
        ip.target_date IS NOT NULL AND DATE(o.order_date) = ip.target_date
      ) OR (
        ip.days_range > 1 AND o.order_date >= CURRENT_DATE - ip.days_range * INTERVAL '1 day'
      )
      AND o.status != 'cancelled'
      GROUP BY DATE(o.order_date)
      ORDER BY sale_date DESC
    result_format: "table"
    tags: ["daily", "sales", "today", "yesterday", "summary", "performance"]
    semantic_tags:
      action: "summarize_daily"
      primary_entity: "sales"
      qualifiers: ["daily", "performance"]
    approved: true

  - id: customer_order_frequency_analysis # FIXME
    version: "1.0.0"
    description: "Analyze how frequently customers place orders"
    nl_examples:
      - "How often do customers order?"
      - "Show me customer ordering patterns"
      - "Customer purchase frequency analysis"
      - "How many times do customers typically order?"
      - "Show repeat customer behavior"
      - "Customer ordering frequency breakdown"
    parameters:
      - name: days_back
        type: integer
        description: "Period to analyze"
        required: false
        default: 365
    sql_template: |
      WITH customer_order_counts AS (
        SELECT 
          customer_id,
          COUNT(*) as order_count
        FROM orders 
        WHERE order_date >= CURRENT_DATE - INTERVAL '%(days_back)s days'
          AND status != 'cancelled'
        GROUP BY customer_id
      )
      SELECT 
        order_count as orders_placed,
        COUNT(*) as customer_count,
        ROUND(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER(), 2) as percentage,
        CASE 
          WHEN order_count = 1 THEN 'One-time buyers'
          WHEN order_count BETWEEN 2 AND 5 THEN 'Occasional buyers'
          WHEN order_count BETWEEN 6 AND 10 THEN 'Regular buyers'
          ELSE 'Frequent buyers'
        END as customer_segment
      FROM customer_order_counts
      GROUP BY order_count
      ORDER BY order_count
    result_format: "table"
    tags: ["customer", "frequency", "patterns", "behavior", "repeat", "analysis"]
    semantic_tags:
      action: "analyze_patterns"
      primary_entity: "customer"
      qualifiers: ["ordering_frequency", "behavior"]
    approved: true

  - id: top_selling_periods
    version: "1.0.0"
    description: "Find the busiest days and times for orders"
    nl_examples:
      - "What are our busiest days?"
      - "When do we get the most orders?"
      - "Show me peak ordering times"
      - "What days have the highest sales?"
      - "Busiest days of the week"
      - "Peak sales periods"
    parameters:
      - name: days_back
        type: integer
        description: "Period to analyze"
        required: false
        default: 90
    sql_template: |
      SELECT 
        TO_CHAR(o.order_date, 'Day') as day_of_week,
        EXTRACT(DOW FROM o.order_date) as day_number,
        COUNT(o.id) as total_orders,
        SUM(o.total) as total_revenue,
        AVG(o.total) as average_order_value,
        ROUND(COUNT(o.id) * 100.0 / SUM(COUNT(o.id)) OVER(), 2) as percentage_of_orders
      FROM orders o
      WHERE o.order_date >= CURRENT_DATE - INTERVAL '%(days_back)s days'
        AND o.status != 'cancelled'
      GROUP BY TO_CHAR(o.order_date, 'Day'), EXTRACT(DOW FROM o.order_date)
      ORDER BY total_orders DESC
    result_format: "table"
    tags: ["busiest", "peak", "days", "times", "selling", "periods", "highest"]
    semantic_tags:
      action: "find_peaks"
      primary_entity: "sales"
      qualifiers: ["time_periods", "busiest"]
    approved: true

  - id: revenue_by_customer_segment # FIXME
    version: "1.0.0"
    description: "Analyze revenue contribution by customer segments"
    nl_examples:
      - "How much revenue comes from each customer type?"
      - "Revenue breakdown by customer segment"
      - "Show revenue from high vs low value customers"
      - "Customer segment revenue analysis"
      - "Which customer groups generate the most revenue?"
    parameters:
      - name: days_back
        type: integer
        description: "Period to analyze"
        required: false
        default: 365
    sql_template: |
      WITH customer_totals AS (
        SELECT 
          c.id,
          c.name,
          c.city,
          c.country,
          COUNT(o.id) as order_count,
          SUM(o.total) as total_spent
        FROM customers c
        JOIN orders o ON c.id = o.customer_id
        WHERE o.order_date >= CURRENT_DATE - INTERVAL '%(days_back)s days'
          AND o.status != 'cancelled'
        GROUP BY c.id, c.name, c.city, c.country
      )
      SELECT 
        CASE 
          WHEN total_spent >= 5000 THEN 'VIP Customers (>$5000)'
          WHEN total_spent >= 2000 THEN 'High Value ($2000-$5000)'
          WHEN total_spent >= 500 THEN 'Regular ($500-$2000)'
          WHEN total_spent >= 100 THEN 'Occasional ($100-$500)'
          ELSE 'Low Value (<$100)'
        END as customer_segment,
        COUNT(*) as customer_count,
        SUM(total_spent) as segment_revenue,
        AVG(total_spent) as avg_customer_value,
        ROUND(SUM(total_spent) * 100.0 / SUM(SUM(total_spent)) OVER(), 2) as revenue_percentage
      FROM customer_totals
      GROUP BY 
        CASE 
          WHEN total_spent >= 5000 THEN 'VIP Customers (>$5000)'
          WHEN total_spent >= 2000 THEN 'High Value ($2000-$5000)'
          WHEN total_spent >= 500 THEN 'Regular ($500-$2000)'
          WHEN total_spent >= 100 THEN 'Occasional ($100-$500)'
          ELSE 'Low Value (<$100)'
        END
      ORDER BY segment_revenue DESC
    result_format: "table"
    tags: ["revenue", "customer", "segment", "high", "low", "value", "groups", "contribution"]
    semantic_tags:
      action: "segment_analysis"
      primary_entity: "revenue"
      qualifiers: ["by_customer_segment"]
    approved: true

  - id: order_completion_rate_by_status
    version: "1.0.0"
    description: "Analyze order completion rates and status distribution"
    nl_examples:
      - "What's our order completion rate?"
      - "How many orders get cancelled?"
      - "Order status breakdown"
      - "Show me fulfillment success rate"
      - "Order processing statistics"
      - "How many orders complete successfully?"
    parameters:
      - name: days_back
        type: integer
        description: "Period to analyze"
        required: false
        default: 30
    sql_template: |
      SELECT 
        o.status,
        COUNT(*) as order_count,
        ROUND(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER(), 2) as percentage,
        SUM(o.total) as total_revenue,
        AVG(o.total) as average_order_value,
        CASE 
          WHEN o.status = 'delivered' THEN 'Completed'
          WHEN o.status = 'cancelled' THEN 'Failed'
          WHEN o.status IN ('pending', 'processing', 'shipped') THEN 'In Progress'
          ELSE 'Other'
        END as status_category
      FROM orders o
      WHERE o.order_date >= CURRENT_DATE - INTERVAL '%(days_back)s days'
      GROUP BY o.status
      ORDER BY order_count DESC
    result_format: "table"
    tags: ["completion", "rate", "status", "cancelled", "fulfilled", "success", "processing"]
    semantic_tags:
      action: "analyze_rates"
      primary_entity: "order"
      qualifiers: ["completion_rate", "status_distribution"]
    approved: true

  - id: average_order_value_trends
    version: "1.0.0"
    description: "Track average order value trends over time"
    nl_examples:
      - "How has our average order value changed?"
      - "AOV trends over time"
      - "Is our average order value going up or down?"
      - "Show me average order value by month"
      - "Average order value analysis"
      - "AOV performance trends"
    parameters:
      - name: period
        type: string
        description: "Grouping period (daily, weekly, monthly)"
        required: false
        default: "monthly"
        allowed_values: ["daily", "weekly", "monthly"]
      - name: days_back
        type: integer
        description: "Period to analyze"
        required: false
        default: 180
    sql_template: |
      SELECT 
        CASE 
          WHEN %(period)s = 'daily' THEN TO_CHAR(o.order_date, 'YYYY-MM-DD')
          WHEN %(period)s = 'weekly' THEN TO_CHAR(DATE_TRUNC('week', o.order_date), 'YYYY-MM-DD')
          ELSE TO_CHAR(DATE_TRUNC('month', o.order_date), 'YYYY-MM')
        END as time_period,
        COUNT(o.id) as total_orders,
        SUM(o.total) as total_revenue,
        ROUND(AVG(o.total), 2) as average_order_value,
        MIN(o.total) as min_order_value,
        MAX(o.total) as max_order_value
      FROM orders o
      WHERE o.order_date >= CURRENT_DATE - INTERVAL '%(days_back)s days'
        AND o.status != 'cancelled'
      GROUP BY 
        CASE 
          WHEN %(period)s = 'daily' THEN TO_CHAR(o.order_date, 'YYYY-MM-DD')
          WHEN %(period)s = 'weekly' THEN TO_CHAR(DATE_TRUNC('week', o.order_date), 'YYYY-MM-DD')
          ELSE TO_CHAR(DATE_TRUNC('month', o.order_date), 'YYYY-MM')
        END
      ORDER BY time_period
    result_format: "table"
    tags: ["average", "order", "value", "AOV", "trends", "changed", "performance"]
    semantic_tags:
      action: "track_trends"
      primary_entity: "order_value"
      qualifiers: ["average", "trends"]
    approved: true

  - id: customer_lifetime_value_distribution # FIXME
    version: "1.0.0"
    description: "Show distribution of customer lifetime values"
    nl_examples:
      - "What's the distribution of customer values?"
      - "How are customer lifetime values spread?"
      - "Customer value distribution analysis"
      - "Show me customer value ranges"
      - "Customer lifetime value breakdown"
    parameters: []
    sql_template: |
      WITH customer_values AS (
        SELECT 
          c.id,
          c.name,
          SUM(o.total) as lifetime_value
        FROM customers c
        LEFT JOIN orders o ON c.id = o.customer_id AND o.status != 'cancelled'
        GROUP BY c.id, c.name
      )
      SELECT 
        CASE 
          WHEN lifetime_value = 0 THEN '$0 (No Orders)'
          WHEN lifetime_value < 100 THEN '$1-$99'
          WHEN lifetime_value < 500 THEN '$100-$499'
          WHEN lifetime_value < 1000 THEN '$500-$999'
          WHEN lifetime_value < 2500 THEN '$1000-$2499'
          WHEN lifetime_value < 5000 THEN '$2500-$4999'
          ELSE '$5000+'
        END as value_range,
        COUNT(*) as customer_count,
        ROUND(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER(), 2) as percentage,
        SUM(lifetime_value) as total_revenue_in_range,
        ROUND(AVG(lifetime_value), 2) as avg_value_in_range
      FROM customer_values
      GROUP BY 
        CASE 
          WHEN lifetime_value = 0 THEN '$0 (No Orders)'
          WHEN lifetime_value < 100 THEN '$1-$99'
          WHEN lifetime_value < 500 THEN '$100-$499'
          WHEN lifetime_value < 1000 THEN '$500-$999'
          WHEN lifetime_value < 2500 THEN '$1000-$2499'
          WHEN lifetime_value < 5000 THEN '$2500-$4999'
          ELSE '$5000+'
        END
      ORDER BY MIN(lifetime_value)
    result_format: "table"
    tags: ["customer", "lifetime", "value", "distribution", "ranges", "spread", "breakdown"]
    semantic_tags:
      action: "analyze_distribution"
      primary_entity: "customer"
      qualifiers: ["lifetime_value", "distribution"]
    approved: true

  - id: seasonal_sales_patterns
    version: "1.0.0"
    description: "Analyze seasonal sales patterns and trends"
    nl_examples:
      - "What are our seasonal sales patterns?"
      - "Do we have seasonal trends?"
      - "Sales by season analysis"
      - "When do we sell the most?"
      - "Seasonal revenue patterns"
      - "Show me sales by quarter"
    parameters:
      - name: year
        type: integer
        description: "Year to analyze"
        required: false
        default: 2025
    sql_template: |
      SELECT 
        CASE 
          WHEN EXTRACT(MONTH FROM o.order_date) IN (12, 1, 2) THEN 'Winter'
          WHEN EXTRACT(MONTH FROM o.order_date) IN (3, 4, 5) THEN 'Spring'
          WHEN EXTRACT(MONTH FROM o.order_date) IN (6, 7, 8) THEN 'Summer'
          ELSE 'Fall'
        END as season,
        EXTRACT(QUARTER FROM o.order_date) as quarter,
        COUNT(o.id) as total_orders,
        SUM(o.total) as total_revenue,
        AVG(o.total) as average_order_value,
        COUNT(DISTINCT o.customer_id) as unique_customers,
        ROUND(COUNT(o.id) * 100.0 / SUM(COUNT(o.id)) OVER(), 2) as percentage_of_orders
      FROM orders o
      WHERE EXTRACT(YEAR FROM o.order_date) = %(year)s
        AND o.status != 'cancelled'
      GROUP BY 
        CASE 
          WHEN EXTRACT(MONTH FROM o.order_date) IN (12, 1, 2) THEN 'Winter'
          WHEN EXTRACT(MONTH FROM o.order_date) IN (3, 4, 5) THEN 'Spring'
          WHEN EXTRACT(MONTH FROM o.order_date) IN (6, 7, 8) THEN 'Summer'
          ELSE 'Fall'
        END,
        EXTRACT(QUARTER FROM o.order_date)
      ORDER BY quarter
    result_format: "table"
    tags: ["seasonal", "patterns", "trends", "quarter", "season", "Winter", "Spring", "Summer", "Fall"]
    semantic_tags:
      action: "analyze_patterns"
      primary_entity: "sales"
      qualifiers: ["seasonal", "patterns"]
    approved: true
